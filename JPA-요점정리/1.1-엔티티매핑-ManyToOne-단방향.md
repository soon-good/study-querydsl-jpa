# 1.1 엔티티매핑 ManyToOne 단방향

엔티티의 연관관계 매핑을 어떻게 설정하는지에 따라 불필요한 조인을 줄일 수도 있고, 조회 성능을 개선할 수 있다. optional 등과 같은 속성을 알맞게 사용하면, 필요한 데이터를 가져오는 시점을 결정할 수도 있다. 그래도 가장 중요한 건 엔티티 매핑에 지나치게 의존해서 너무 객체지향으로 표현하려고 하는 것보다는, 불필요한 조인을 줄이고 인덱스 값으로 조회를 바로 할 수 있는 그런 테이블 설계를 먼저 하는게 더 중요하지 않을까 하는 생각이 있다.<br>

<br>

엔티티 매핑을 이해할 때 이해가 쉬우려면 핵심적으로 염두에 두어야 하는 사항은 이렇다. <br>

> 테이블 두개를 조인할 때 어떤 컬럼을 조인하도록 할지, 이런 관계를 테이블에서 클래스 내의 필드로 옮겨오면 어떻게 두 테이블 간의 관계를 객체간의 관계로 옮겨왔을까?

하는 것에 주안점을 두면 이해가 쉽다.<br>

<br>

테이블을 설계를 하면서 염두에 두어야 하는 내용은 아래와 같다고 생각한다.(조금은 주관적이다.)<br>

> - 굳이 조인을 하게끔 두어야 하는 것일까? 테이블 설계를 통해 단일 시퀀스로 접근할 수 있게끔 하는 방법은 없는지 찾아볼수는 없을까? 
> - 만약 조인을 해야만 한다면, 페이지네이션 등을 적용해서 조인 쿼리를 최대한 가볍게 만들만한 요소는 없을까?

<br>

예제는 추후 글의 최 하단에 여러가지 케이스로 추가할 예정이다. 오늘은 일단 개념들을 매우 깔끔하게 10분만에 모두 읽을 수 있을 정도로 요약해보는게 목표이다.<br>

<br>

## 엔티티 매핑 기준 

**TODO : 엔티티 매핑 기본 내용인 엔티티 매핑 기준 관련해서 정리하는 문서를 따로 문서 하나 만들기**<br>

엔티티의 연관관계를 매핑하는 기준은 두 가지가 있다.<br>

- 방향성 (Direction)
  - 양방향 vs 단방향
  - 개인적인 의견으로는, 양방향의 경우 설계시 주의해야 하는 것 같다. 데이터가 상용에서 기하급수적으로 많이 쌓일 수록 양방향 설정시 조회속도가 느려질 수 있다는 생각이다. 물론 지연된 읽기 등을 통해 지연로딩 등을 설정 가능하지만, 양방향 매핑의 경우 너무 개발 편의성 적인 측면이 더 크다는 생각이 크다.
  - 양방향 관계가 문제가 있을 경우 기획적인 면에서 페이지네이션으로 가져오는 데이터의 양을 한정하거나 또는 테이블 설계를 통해 단방향으로 최적화하는 방법이 있을것 같다.
- 다중성 (Multiplicity)
  - 여러가지 매핑 방식들이 있다. (N:1, 1:N, 1:1, N:M)

<br>

## 엔티티 매핑시 공통 지정 속성들

@ManyToOne, @OneToMany, @ManyToMany 는 아래의 필드들을 대부분 공통으로 가진다. <br>(참고 : @ManyToMany 의 경우 optional이 없다.) <br>

객체와 상대편 객체 간의 연관관계를 갖는 것은 물리적인 SQL로 풀어서 작성하면, 결국 조인을 해야 한다는 의미와 같다.<br>

아래의 속성들은 SQL을 조금 늦게 가져올지, Inner Join/Outer Join 을 할지, 수정/삭제 연산시 영속성 전이를 일으키는 전략은 어떻게 할지를 지정하는 속성이다.<br>

<br>

- fetch
  - 지연로딩 vs 즉시로딩
- optional
  - 기본 join 전략을 outer join 으로 할지 inner join 으로 할지에 대한 속성
  - @ManyToOne
    - 기본 설정 : optional = true (outer join 이 수행된다)
  - @OneToMany
    - 기본설정 : optional = false (inner join 이 수행된다)
- cascade

<br>

## ManyToOne, 다대일

가장 기본적인 매핑관계이다. 대학에 입학하면 항상 배우는 Employee, Department 기반의 SQL 예제가 ManyToOne으로 표현할 수 있다. 오늘 매핑관리를 정리할 것들은 ManyToOne 기반의 예제를 정리해볼 예정이다.<br>

개인적으로 `다대일` 이라는 용어는 이상하게 일본어 같아보여서, 일단은 원래 용어인 ManyToOne 이라는 용어를 그대로 사용할 생각이다. python 기반의 django 에서도 `ManyToOne`이라는 용어가 있다. Node 에서도 ManyToOne 이라는 용어가 있다. 그래서 그냥 ManyToOne 이라는 용어를 사용하는게 맞지 않나 하는 생각이 있다.<br>

<br>

### ManyToOne 의 속성들

`optional`<br>

- 연관된 상대편 엔티티의 데이터를 반드시 가져와야 하는지의 여부를 결정한다.

- false 로 설정하면 항상 연관된 상대편 데이터를 반드시 가져와야 한다는 의미이다.

- > @ManyToOne(optional = false) : Inner Join, Employee.dept 가 null 이 될수 없다. 

- > @ManyToOne(optional = true) : Outer Join, Employee.dept 가 null 이어도 가져온다.

- 영속성 컨테이너의 @ManyToOne 에 대한 기본 설정은 optional = true 이다. 즉, 기본 설정은 OUTER JOIN 에 해당하는 쿼리를 생성한다.

- 따라서, 조인 조건에 일치하는 경우의 데이터만 조회해야 하는 경우 성능이 느린 Outer Join 보다는 Inner Join 을 이용해야 한다. 따라서 명시적으로 `@ManyToOne(optional = false)` 로 설정해야 한다.

- 참고)

  - @ManyToOne 의 연관관계 반대편인 @OneToMany의 경우 기본 설정이 optional = true 

`fetch` <br>

- `FetchType.EAGER` 
  - 연관관계 엔티티 데이터를 조회와 동시에 가져온다.
- `FetchType.LAZY`
  - 연관관계에 해당하는 상대편의 데이터는 실제로 사용할 때에 가죠온다.
  - 실제 데이터가 사용되는 시점까지 가져오는 시점을 지연 시키라는 의미.
- @ManyToOne 의 fetch 속성은 기본 값이 `FetchType.EAGER` 이다. 
  - (One 에 해당하는 객체가 하나 밖에 없기 때문에 다(Many)에 해당하는 객체를 조회했을 때, One 에 해당하는 객체를 조인으로 즉시(EAGER) 가져오는 것이 효율적일 수 있기에 기본 설정이 이렇게 되어 있음)
- 참고)
  - OneToMany 의 경우 기본 설정이 `fetch = FetchType.LAZY` 이다.

`cascade`<br>

- 영속성 전이 기능을 설정한다.
- 연관 엔티티를 같이 저장하거나 삭제할 때 사용

<br>

###  ex) Employee, Department 

**ManyToOne** (다대일) 관계를 정리하기 위해 Employee, Department 기반의 예제를 기반으로 정리할 예정이다. 해당 클래스들은 아래와 같다.(예제는 Postgresql 기준)<br>

<br>

 ### Employee.java

```java
@Data
@Entity
@Table(name = "EMP")
public class Employee{
  @Id @GeneratedValue(strategy = GenerationType.SEQUENCE)
  private Long id;
  
  @Column(length = 25, nullable = false)
  private String id;
  
  @ManyToOne
  @JoinColumn(name = "DEPT_ID")
  private Department dept;
}
```

<br>

### Department.java

```java
@Data
@Entity
@Table(name = "DEPT")
public class Department{
  @Id @GeneratedValue(strategy = GenerationType.SEQUENCE)
  @Column(name = "DEPT_ID")
  private Long id;
  
  @Column(name = "DEPT_NAME")
  private String deptName;
}
```

<br>

## @ManyToOne, @JoinColumn - Employee.java

Employee.java 의 내용을 보면 아래와 같이 `@JoinColumn` 어노테이션이 변수 `Department dept` 에 적용되어 있다.<br>

`@JoinColumn`은 DEPT 테이블과 EMP 테이블을 조인에 사용할 때 사용할 객체 내의 변수에 지정하는 어노테이션이다.<br>

`@ManyToOne` 이 적용된 필드에 `@JoinColumn` 을 생략하면 JPA 는 아래와 같은 규칙으로 컬럼이름이 아래와 같은 규칙으로 생성된다.<br>

>  참조변수 이름 + "_" + 참조하는 테이블의 주 키 컬럼 명
>
> create table S_EMP (
>
> ​	id bigint generated by default as identity,
>
> ​	name archer(25) not null,
>
> ​	dept_DEPT_ID begint,
>
> ​	primary key (id)
>
> )

<br>

@ManyToOne 을 멤버필드에 지정하면, 해당 객체내의  @Id 에 지정한 타입에 따라 테이블 내에 컬럼이 추가된다.

(아래 예제의 경우 DEPT_ID 가 EMP 테이블에 추가된다.)

```java
@Data
@Entity
@Table(name = "EMP")
public class Employee{
  @Id @GeneratedValue(strategy = GenerationType.SEQUENCE)
  private Long id;
  
  @Column(length = 25, nullable = false)
  private String id;
  
  @ManyToOne
  @JoinColumn(name = "DEPT_ID")
  private Department dept;
}
```

<br>

## 참고) @OneToMany, mappedBy - Department.java

양방향으로 설정할 경우는 `@OneToMany` 내에 `mappedBy` 로 상대편 객체를 지정해준다. 주로 컬렉션이 지정된다. 오늘 정리할 문서에서는 단방향 엔티티 매핑을 정리할 것이기 때문에 mappedBy 에 관련된 내용을 생략할 예정이다. <br>

오늘 정리할 내용은 아래와 같은 단방향 기반 예제이다.<br>

처음 공부할 때 단방향은 조인이 걸리지 않는다고 자주 착각했었다. 단방향 역시도 조인이 걸린다.<br>

아래 Department.java 클래스를 보면 `Long id` 로 선언된 필드가 보인다. 이 필드는 상대편 클래스인 Employee.java 내에서 아래와 같은 구문으로 참고하고 있다.<br>

> @ManyToOne<br>
>
> @JoinColumn(name = "DEPT_ID")<br>
>
> private Department dept;<br>

<br>

```java
@Data
@Entity
public class Department{
  @Id @Column(name = "DEPT_ID")
  @GeneratedValue(strategy = GenerationType.SEQUENCE)
  private Long id;
  
  @Column(name = "DEPT_NAME")
  private String deptName;
  
  // 다음 문서에서 정리할 예정
  // @OneToMany(mappedBy = "dept")
  // private List<Employee> employeeList;
}
```

<br>

## optional

[@ManyToOne](https://docs.jboss.org/hibernate/jpa/2.2/api/javax/persistence/ManyToOne.html) 의 옵션 중 optional 의 기본설정은 `optional = true` 이다.<br>

연관관계를 맺는 상대편 필드가 null 이 아닌 값들만을 조인해서 가져올지, null 인 값들도 조인해서 가져올지를 결정하는 필드이다.<br>

optional 이라는 단어에서 느껴지듯이, 필드가 옵션 같은 성격이 맞다면 true, 옵션 같은 성격이 아니라면 false 를 지정한다.<br>

<br>

- optional = true
  - optional = true 로 세팅하면, left outer join 을 수행하게 된다.
  - `@ManyToOne` 의 기본 설정은 optional = true 이다.
  - left outer join 의 경우 성능 측면에서는 조금 불리한 측면이 있다.
    - left outer join 쿼리는 조인을 하는 상대편 테이블 내의 null 이 아닌 로우도 같이 들고와야 하는 경우에 사용한다.
  - `@ManyToOne` 의 상대편 테이블은 One 에 해당하는 연관관계이므로, 조인할 대상이 상대적으로 적기 때문에 jpa의 `@ManyToOne` 의 One 에 대한 Join은 left outer join 으로 지정하고 있다.
- optional = false
  - inner join 을 수행하게 된다.

<br>

### 예제 (1) 단건조회 시 SQL (optional = true)

**ManyToOneFetchOptionalTest.java**

```java
@Transactional
@SpringBootTest
class ManyToOneFetchOptionalTest {

    @Autowired
    EntityManager em;

    @Autowired
    private EmployeeRepository employeeRepository;

    @Autowired
    private DepartmentRepository departmentRepository;

    @BeforeEach
    public void init(){
        Department deptSoccer = new Department("축구선수");
        Department deptSinger = new Department("가수");

        em.persist(deptSoccer);
        em.persist(deptSinger);

        Employee e1 = new Employee("황의조", deptSoccer);
        Employee e2 = new Employee("손흥민", deptSoccer);
        Employee e3 = new Employee("권창훈", deptSoccer);
        Employee e4 = new Employee("지드래곤", deptSinger);
        Employee e5 = new Employee("블랙핑크", deptSinger);
        em.persist(e1);
        em.persist(e2);
        em.persist(e3);
        em.persist(e4);
        em.persist(e5);
    }

    @Test
    @DisplayName("optional_false_테스트_단건조회")
    public void optional_false_테스트_단건조회(){
        em.flush();
        em.clear();
        Employee e1 = employeeRepository.findById(3L).orElseGet(()->{
            return new Employee();
        });

        System.out.println("e1 >>> " + e1.toString());
    }
}
```

<br>

위 코드에서 단건 조회로 엔티티 조회를 하는 부분은 아래와 같다.

```java
@Test
@DisplayName("optional_false_테스트_단건조회")
public void optional_false_테스트_단건조회(){
  em.flush();
  em.clear();
  Employee e1 = employeeRepository.findById(3L).orElseGet(()->{
    return new Employee();
  });

  System.out.println("e1 >>> " + e1.toString());
}
```

- `em.flush()` , `em.clear()` 
  - JPA는 영속성 컨테이너(=메모리 내의 테이블 객체 매핑 저장소) 내에 엔티티가 없으면 SQL을 수행하게 된다. SQL이 실제로 어떻게 나오는지 확인하기 위해 강제로 `em.flush()` , `em.clear()` 를 사용했다.

**SQL 출력**<br>

```sql
select
    employee0_.employee_id as employee1_1_0_,
    employee0_.dept_id as dept_id3_1_0_,
    employee0_.employee_name as employee2_1_0_,
    department1_.dept_id as dept_id1_0_1_,
    department1_.dept_name as dept_nam2_0_1_ 
from
    public.emp employee0_ 
left outer join
    public.dept department1_ 
        on employee0_.dept_id=department1_.dept_id 
where
    employee0_.employee_id=?

...

e1 >>> Employee{id=3, name='황의조'}
```



### 예제 (2) 단건 조회 시 SQL (optional = false)

**Employee.java**<br>

수정된 부분은 아래와 같다. `@ManyToOne(optional = false)` 으로 변환해주었다.<br>

```java
@Data
@Entity
@Table(name = "EMP", schema = "public")
public class Employee {
  	// ...
    @ManyToOne(optional = false)
    @JoinColumn(name = "DEPT_ID")
    private Department dept;
		// ...
}

```

<br>

**테스트코드**

```java
@Transactional
@SpringBootTest
class ManyToOneFetchOptionalTest {

    @Autowired
    EntityManager em;

    @Autowired
    private EmployeeRepository employeeRepository;

    @Autowired
    private DepartmentRepository departmentRepository;

    @BeforeEach
    public void init(){
        Department deptSoccer = new Department("축구선수");
        Department deptSinger = new Department("가수");

        em.persist(deptSoccer);
        em.persist(deptSinger);

        Employee e1 = new Employee("황의조", deptSoccer);
        Employee e2 = new Employee("손흥민", deptSoccer);
        Employee e3 = new Employee("권창훈", deptSoccer);
        Employee e4 = new Employee("지드래곤", deptSinger);
        Employee e5 = new Employee("블랙핑크", deptSinger);
        em.persist(e1);
        em.persist(e2);
        em.persist(e3);
        em.persist(e4);
        em.persist(e5);
    }

    @Test
    @DisplayName("optional_false_테스트_단건조회")
    public void optional_false_테스트_단건조회(){
        em.flush();
        em.clear();
        Employee e1 = employeeRepository.findById(3L).orElseGet(()->{
            return new Employee();
        });

        System.out.println("e1 >>> " + e1.toString());
    }
}

```

<br>

**단건조회하는 부분**<br>

위 전체 코드 내에서 Employee 객체에 대한 단건 조회를 하는 부분은 아래와 같다.<br>

```java
@Test
@DisplayName("optional_false_테스트_단건조회")
public void optional_false_테스트_단건조회(){
  em.flush();
  em.clear();
  Employee e1 = employeeRepository.findById(3L).orElseGet(()->{
    return new Employee();
  });

  System.out.println("e1 >>> " + e1.toString());
}
```

- `em.flush()` , `em.clear()` 
  - JPA는 영속성 컨테이너(=메모리 내의 테이블 객체 매핑 저장소) 내에 엔티티가 없으면 SQL을 수행하게 된다. SQL이 실제로 어떻게 나오는지 확인하기 위해 강제로 `em.flush()` , `em.clear()` 를 사용했다.

<br>

**SQL 생성결과**<br>

```sql
select
    employee0_.employee_id as employee1_1_0_,
    employee0_.dept_id as dept_id3_1_0_,
    employee0_.employee_name as employee2_1_0_,
    department1_.dept_id as dept_id1_0_1_,
    department1_.dept_name as dept_nam2_0_1_ 
from
    public.emp employee0_ 
inner join
    public.dept department1_ 
        on employee0_.dept_id=department1_.dept_id 
where
    employee0_.employee_id=?

... 

e1 >>> Employee{id=3, name='황의조'}
```

<br>

### 예제 (3) 리스트 조회 시 SQL (optional = true)

**8월마지막주TODO**<br>

<br>

## fetch :: 갑자기 발견한 누락된 항목... 정리시작

**8월마지막주TODO**<br>

즉시로딩 vs 지연로딩에 대한 옵션이다.<br>

fetch 의 경우 `FetchType.LAZY` , `FetchType.EAGER` 의 타입을 주어서 즉시 로딩할지, 지연로딩할지 방법을 결정할 수 있다.<br>

예제를 기반으로 이해하는 게 역시 쉬울 것 같다.

<br>

### 예제

```java
```





