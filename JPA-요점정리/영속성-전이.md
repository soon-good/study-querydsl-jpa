# 영속성 전이

@ManyToOne 정리문서에 이미 예제를 설명을 해놓아서 귀찮아서 파일을 하나 따로 만들지 않았었다. 하지만 하다보니 결국은 파일을 하나 더 만들어야 했었다.<br>

일단 결론부터 적고 시작해야 할 것 같다. 영속성 전이를 사용하기보다는, null 객체로 세팅하고 연관관계 편의 메서드를 통해 잘 조합을 해서 하나의 트랜잭션 단위를 의미를 지어서 구분지어 놓는 것이 좋은 방식인 것 같다. 자동으로 처리되게끔 영속성 전이를 걸어놓았는데, 최악의 경우, 데이터 삭제시 참조의 참조, 그 참조의 또 참조 까지 타고 내려가면서 알수 없는 데이터까지 삭제되게 되는 대참사가 발생할 수도 있기 때문이다.<br>

<br>

## 예제 엔티티 매핑

예제로 사용할 엔티티 매핑은 아래와 같다 ([참고](https://github.com/gosgjung/study-querydsl-jpa/blob/develop/JPA-%EC%9A%94%EC%A0%90%EC%A0%95%EB%A6%AC/1.1-%EC%97%94%ED%8B%B0%ED%8B%B0%EB%A7%A4%ED%95%91-ManyToOne-%EC%96%91%EB%B0%A9%ED%96%A5.md))

<br>

### Employee.java

```java
// ...

@Getter
@Entity
@Table(name = "EMP", schema = "public")
public class Employee {

    @Id @GeneratedValue(strategy = GenerationType.AUTO)
    @Column(name = "EMPLOYEE_ID")
    private Long id;

    @Column(name = "EMPLOYEE_NAME")
    private String name;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "DEPT_ID")
    private Department dept;

    public Employee(){}

    @Builder
    public Employee(Long id, String name, Department department){
        this.id = id;
        this.name = name;
        this.dept = department;
    }

    public void setDept(Department dept){
        this.dept = dept;
    }

    public void assignDept(Department dept){
        this.dept = dept;
        dept.getEmployees().add(this);
    }
}
```

<br>

### Department.java

```java
// ...

@Getter
@Entity
@Table(name = "DEPT", schema = "public")
public class Department {

    @Id @GeneratedValue(strategy = GenerationType.AUTO)
    @Column(name = "DEPT_ID")
    private Long id;

    @Column(name = "DEPT_NAME")
    private String deptName;

    @OneToMany(mappedBy = "dept", fetch = FetchType.LAZY)
    private final List<Employee> employees = new ArrayList<>();

    public Department(){}

    @Builder
    public Department(Long id, String deptName){
        this.id = id;
        this.deptName = deptName;
    }
}
```

<br>

## 비영속 상태의 엔티티를 다른 객체에 지정하여 저장할때

```java
// ...
@SpringBootTest
@Transactional
public class WithoutCascadeTest {

	@Autowired
	EntityManager em;

	@Transactional
	@Test
	void 테스트_NEW_상태의_객체를_PERSIST_할경우(){
		Department deptSoccer = Department.builder().deptName("축구선수").build();

		Employee son = Employee.builder()
			.name("손흥민")
			.department(deptSoccer)
			.build();

		Employee hwang = Employee.builder()
			.name("황의조")
			.department(deptSoccer)
			.build();

		deptSoccer.getEmployees().add(son);
		deptSoccer.getEmployees().add(hwang);

		// em.persist(deptSoccer);
		em.persist(son);em.persist(hwang);
		em.flush();
	}
}
```

위의 예제에서 주목할 부분은 아래와 같다.

```java
Department deptSoccer = Department.builder().deptName("축구선수").build();

// ...

deptSoccer.getEmployees().add(son);
deptSoccer.getEmployees().add(hwang);

// em.persist(deptSoccer);
em.persist(son);em.persist(hwang);
em.flush();
```

이렇게 하면 deptSoccer 객체는 persist 하지 않았기 때문에 비영속 상태의 객체다. 그런데 이 객체가 EntityManager 를 거치지 않는다면 전혀 에러가 나지 않는데, 아래와 같이 관리 상태의 객체 내에 세팅을 해주고 있다.

```java
Employee son = Employee.builder()
  .name("손흥민")
  .department(deptSoccer)
  .build();
```

관리 상태의 객체에서 비영속 상태의 객체를 세팅해주고 잇는데, 이것을 아래와 같이 persist 할 경우 에러를 내게 된다.

```java
em.persist(son);
em.persist(hwang);
```

즉, 객체하나에 다른 엔티티 객체를 담아서 persist 할경우 해당 다른 객체 역시도 관리 상태에 있어야 한다는 것이다.

<br>

## 영속성 전이 (cascade)

영속성을 전이 시킨다는 개념이다. 영속성으로 지정되지 않았어도 저장할 때 일괄적으로 저장할 수록 있도록 하거나 하는 개념이다. 영속성 전이는 @ManyToOne, @OneToOne, @OneToMany, @ManyToMany 에서 모두 cascade 라는 속성으로 지정 가능하다.<br>

영속성 전이로 지정할 수 있는 타입들은 아래와 같다.

![이미지](./img/CASCADE/1.png)

- ALL
- PERSIST
- MERGE
- REMOVE
- REFRESH
- DETACH

이렇게 6가지의 CascadeType 이 있다.

---

나머지는 내일부터... 이제부터는 일을 해야 해서...