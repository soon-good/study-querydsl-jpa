# 1.1 엔티티매핑 ManyToOne 양방향

막상 글을 쓰려고 하다보니 뭐부터 시작해야 할 지도 모르겠고, 머릿속으로는 너무나 쉽게 만들어지고, 예제로도 엄청 쉽게 작성하는 것을 글로 설명하는 것은 정말 힘들었다. 썼다 지웠다를 정말 한시간 이상 반복했다.<br>

오늘은 일단 개념정리다. 개념 설명하는게 진짜 힘들다. 나도 모르게 적었던 문장을 반복할까봐 계속 의식하면서 정리하게 됬었다.<br>

<br>

## 참고자료



## ManyToOne 

다대일이라는 말로 많이 불리는 개념인데, 일본어 같기도 하고 전문용어처럼 따로 용어를 부르는게 마음에 들지 않아서 그냥 ManyToOne 이라고 부르는 편이다.<br>

ManyToOne 양방향을 공부하기 시작하기 전에, 한가지 개념을 살짝 요약해둬야 할 것 같다. 연관관계의 주인이라는 개념이다.<br>

<br>

## 연관관계의 주인

흔히 연관관계의 주인은 @JoinColumn 어노테이션으로 상대편 객체의 키를 바인딩한다.<br>

@JoinColumn 이 표기된 필드는 테이블 개념으로 표현했을 때 외래키를 의미한다. <br>

그리고 이렇게 외래키를 소유한 테이블을 표현한 객체 클래스를 연관관계의 주인이라고 부른다.<br>

Employee 와 Department 테이블의 서로간의 관계는 아래와 같이 표현한 경우를 예로 들수 있다.<br>

![이미지](./img/MANY-TO-ONE-BOTH-WAY/1.png)

<br>

Employee 테이블은 DEPT_NO 라는 컬럼을 가지고 있다. 그리고 Employee 테이블이 소유하고 있는 DEPT_NO 컬럼은 상대편 테이블인 DEPARTMENT 테이블의 기본키인 DEPT_NO 로 데이터 하나를 고유하게 식별하기 위한 컬럼이다. 이렇게 테이블 하나에서 다른 테이블의 키(PK)를 가지고 있는 경우 이 키를 외래키(FK)라고 부른다.<br>

그리고 이 외래키를 소유한 Employee 테이블과, 매핑을 당하는 입장인 Department 테이블을 양방향 객체의 관계로 표현해보면 아래와 같다. (그림을 잃어버려서 다시 그리느라 시간이 조금 걸렸었다.)<br>

![이미지](./img/MANY-TO-ONE-BOTH-WAY/2.png)

<br>

**Employee 객체 내의 dept 필드**<br>

Department 의 외래키를 관리하기 위해 Department 를 참조하는 필드이다. 외래키를 관리하는 이런 필드들은 보통 `@JoinColumn` 이라는 애노테이션을 추가해준다.<br>

멤버필드 dept 처럼 외래키(@JoinColumn)와 매핑하는 참조변수를 연관관계의 주인(Owner)라고 부른다.<br>

<br>

**Department 객체 내의 employees 필드**<br>

부서 내에 속한 여러 명의 직원들의 데이터를 List 형태로 바인딩하고 있다. <br>

필드 employees 처럼 상대편 테이블의 @JoinColumn 에 의해 매핑당하는 변수는 어노테이션에 mappedBy를 지정해준다.<br>

<br>

## mappedBy

아쉽게도 JPA 에서는 연관관계의 주인 또는 주인테이블을 명확히 표시하는 키워드가 없다. 대신 mappedBy 라는 키워드로 주인 테이블의 상대편을 암묵적으로 표시할 수 있다.<br>

즉, 요약해보면 이렇다.

- 연관관계의 주인, 주인테이블 표현객체 (= ex. Employee 객체)
  - mappedBy 키워드가 없고 @JoinColumn 어노테이션으로 외래키들을 표현해놓은 엔티티
- 연관관계의 주인의 상대편, 상대편 테이블 표현객체 (= ex. Department 객체)
  - mappedBy 키워드가 있는 엔티티 클래스

그래서... 엄청 처음 공부하는 입장이라면 그냥 쉽게 `@JoinColumn 어노테이션이 있는 곳은 연관관계의 주인` 이고, `mappedBy 키워드가 있는 엔티티는 연관관계의 주인의 상대편` 으로 외워두는게 낫지 않을까 싶다.<br>

> - Django, Node.js 같은 프레임워크에서는 그런 키워드가 있을지 궁금하기는 하다. 오히려 Node.js가 객체 관계 표현은 더 쉽지 않을까 싶기도 하다.<br>
> - 외래키를 가지고 있는 테이블은 흔히 주인테이블이라고 부른다. 남의 테이블의 킷값을 가지고 있어서 그런가 보다 싶기는 하다. <br>

<br>

## 양방향 매핑 시의 객체와 테이블의 차이점

**테이블**<br>

컬럼 명을 기반으로 서로 다른 테이블과 서로 키의 값으로 서로를 비교해 매핑을 할 수 있다.<br>

**ex)**

```sql
select e.e.username, e.salary, e.dept_no, d.dept_name
from employee e
inner join department d
on e.dept_no = d.dept_no
```

<br>

employee 테이블에서 department 의 dept_id 가 필요하면 그냥 값이 같은 행을 찾아서 병합하는 과정을 거친다.예를 들면 아래와 같은 방식이다.<br>

![이미지](./img/MANY-TO-ONE-BOTH-WAY/3.png)

<br>

**객체**

테이블의 매핑관계에 비해 조금 복잡해진다. 객체를 양방향으로 연결하려면 객체 양쪽에 서로를 참조하는 변수를 두어야 한다.<br>

단적인 예를 들어보면, 서로 다른 두 객체가 참조관계를 가지려면 아래와 같이 서로의 메모리 주소를 알 수 있도록 해주는 참조변수를 양쪽에 하나씩 가지고 있어야 한다.

ex)

**Employee.java**<br>

```java
@Getter @Setter
public class Employee{
    private String name;
    private Double salary;
    private Department deptNo;
}
```

<br>

**Department.java**<br>

```java
public class Department{
    private Long deptNo;
    private Employee emp;   // 상대편인 Employee 를 참조하는 변수다.
}
```

<br>

양방향 매핑에서는 위의 그림처럼 단적으로 연결되지는 않는다. @ManyToOne 의 경우 프로그램에 테이블의 데이터를 올려둘때 예를 들면 아래와 같은 데이터의 묶음을 표현하게 된다.<br>

```javascript
var 의적 = {
  id: 1,
  dept_name: 의적,
  employeeList: [		// 부서 입장에서는 직원 객체들이 이곳에 말려들어가야 한다.
    {id:1, name:'홍길동', dept_id:1},
    {id:2, name:'전우치', dept_id:1},
  ]
},
var 영화배우 = {
  id: 2,
  dept_name: '영화배우',
  employeeList: [		// 부서 입장에서는 직원 객체들이 이곳에 말려들어가야 한다.
    {id:3, name: '강동원', dept_id:2}
  ]
},
var 축구선수 = {
  id: 3,
  dept_name: '축구선수',
  employeeList: {		// 부서 입장에서는 직원 객체들이 이곳에 말려들어가야 한다.
    {id:4, name: '손흥민', dept_id:3},
    {id:5, name: '황의조', dept_id:3}
  }
}
```

javascript 로 표현해봤는데, 설명이 투머치하고, 뭔가 요점이 없는 느낌이 있어서 이 부분은 다시 정리를 해야 하지 않을까싶다. <br>

<br>

## @ManyToOne, @OneToMany 의 기본 fetch

**@ManyToOne 의 fetch 기본 설정값은 FetchType.EAGER 이다.**<br>

One 에 해당하는 객체가 하나 밖에 없으므로 Many 에 해당하는 객체 조회시 즉시 가져오는 것을 효율적으로 가정한 기본 설정값. 항상 그렇듯 기본 옵션은 항상 커스터마이징해야 한다.<br>

**@OneToMany 의 fetch 기본 설정값은 FetchType.LAZY 이다.**<br>

Many에 해당하는 객체가 많기 때문에 가능한 지연로딩하는 것이 유리하다...는 것을 가정한 기본 설정값.<br>

<br>

## @ManyToOne 의 optional

@ManyToOne 의 기본 optional 설정은 true다. 즉, 아무런 설정도 하지 않으면 outer join 으로 값을 가져온다.

<br>

## @ManyToOne 기반 도메인 로직 구현시 주의사항

연관관계의 주인의 맞은 편은 @OneToMany 관계를 맺게 되는데, 이 @OneToMany 관계를 갖는 엔티티는 주로 List, Set 형태의 데이터를 갖게 된다.



## 예제모음

### 엔티티 매핑



###  테스트 코드 1) Department 에만 Employee 를 추가했을 경우

> List, Set 자료형에만 Employee 를 추가하고, 주인 객체에는 아무 작업도 하지 않았을 경우 <br>



### 테스트 코드 2) Employee 에만 Department 를 추가했을 경우

수요일 저녁에 정리 고고 



## cascade

