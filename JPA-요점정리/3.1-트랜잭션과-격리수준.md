# 트랜잭션과 격리수준

> 참고
>
> - [트랜잭션 - ko.wikipedia.org](https://ko.wikipedia.org/wiki/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98)
> - [데이터베이스 트랜잭션 - ko.wikipedia.org](https://ko.wikipedia.org/wiki/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4_%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98)

트랜잭션은 여러가지 분야 또는 여러가지 의미로 쓰인다. 이번 문서에서 정리할 트랜잭션의 개념은 **Database 에 대해 수행하는 한 번의 작업의 논리적 단위**이다. <br>

원래는 작년에 한번 공부했었다. 오늘부터 두번째로 트랜잭션의 격리수준과 락 모드를 다시 정리하면서 공부하고 있는데, 단순히 원칙들을 기억하고 암기하는 것만으로는 정확하게 이해하고 있지 않은 것이라는 것을 깨달은 것 같다. 

2차캐시 등에 대한 내용 등등 유익한 내용들이 [자바 ORM 표준 JPA 프로그래밍](https://ridibooks.com/books/3984000009) 에 나와있어서 아주 유용했었다. 하지만, 책에 나온 예제는 ehcache 2 를 기반으로 한 내용이다. 2021년 현재 ehcache 는 v3 가 나온지 오래된 상태이기도 하고, 조금 옛날 책이기에 현재 실정이 업데이트 되지 않은 내용이 있었다. <br>

그래서... 이번 달 또는 다음달 내로 여러가지 종류의 2차 캐시서버(hazelcast, ehcache, ignite...)를 종류별로 구축해서 스프링 애플리케이션과 연동하는 토이 애플리케이션을 만드는 과정도 정리해봐야 할 것 같다.(쓰잘데 없는 짓인것 같다는 생각이 든다면 안할것 같기도 하다.)

<br>

## 참고자료

- [트랜잭션 - ko.wikipedia.org](https://ko.wikipedia.org/wiki/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98)
- [데이터베이스 트랜잭션 - ko.wikipedia.org](https://ko.wikipedia.org/wiki/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4_%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98)
- [자바 ORM 표준 JPA 프로그래밍](https://ridibooks.com/books/3984000009)

<br>

## 트랜잭션과 트랜잭션의 격리수준

애플리케이션 대부분은 동시성 처리가 중요하다. 데이터베이스들은 보통 **READ UNCOMMITTED 를 기본 격리수준으로 사용**한다. 즉, DIRTY READ 가 발생할 수 있는 읽기 수준이 대부분의 데이터베이스들이 채택하고 있는 기본 격리수준이다.<br>

더 높은 격리수준이 필요하면 데이터베이스 트랜잭션이 제공하는 잠금기능을 사용하게 된다.<br>

> **참고) MVCC (Multiversion_concurrency_control)**
>
> - 참고자료 : [MVCC](https://en.wikipedia.org/wiki/Multiversion_concurrency_control)
>
> 최근, 데이터베이스들이 더 많은 **동시성 처리**를 위해 **~~락(Lock)~~** 보다는 **MVCC(Multiversion_concurrency_control)을 사용**하고 있다. MVCC를 사용하는 데이터베이스는 **~~락(Lock)~~**을 사용하는 데이터베이스와는 약간 다른 특성을 지닌다

<br>

## 트랜잭션을 구성하는 기본 원칙 - ACID

트랜잭션은 아래의 네가지 원칙이 보장되어야 한다.

- 원자성(Atomicity)
  - 트랜잭션 내에서 실행한 작업들은 마치 하나의 작업인 것처럼 모두 성공하거나 모두 실패해야 한다.
  - ex) Spring의 @Transactional 에 구현한 내용들에 여러개의 작업단위가 있어도 모두 하나의 작업단위처럼 취급되어서 실패할 경우 해당 작업단위로 롤백된다.
- 일관성(Consistency)
  - 트랜잭션은 데이터베이스의 무결성 제약조건을 항상 만족시켜야 한다.
  - = 모든 트랜잭션은 일관성있는 데이터베이스 상태를 유지해야 한다.
- 격리성(Isolation)
  - 동시에 실행되는 여러개의 트랜잭션들이 서로에게 영향을 미치지 않도록 격리될 수 있어야 한다.
  - 트랜잭션 로직을 구현할 때 가장 보장하기 힘든 원칙이 **격리성**이다. 이런 이유로 ANSI 에서는 네 가지 수준의 격리수준을 정의하고 있다.
  - 이 네 가지 격리 수준 중 하나를 선택해서 트랜잭션 로직을 작성할 수 있다면 트랜잭션의 격리성을 만족하는 것이다.
  - 참고로 격리성을 완벽하게 보장하려면 트랜잭션을 거의 차례대로 수행해야만 한다.
    - 이것을 Serializable 단계라고 하는데, 트래픽이 많은 시스템은 시스템을 느려지게 만들 수 있는 요인이다.
- 지속성(Durability)
  - 트랜잭션을 성공하면 그 결과는 기록되어야 한다.
  - 트랜잭션이 성공했어도 시스템 문제가 발생할 경우, 데이터베이스 로그 등을 이용해 성공한 트랜잭션 내용을 복구할 수 있어야 한다.

<br>

**참고) ACID (Atomicity - Consistency - Isolation - Durability)**<br>

- ACID ([en.wikipedia.org/wiki/ACID](https://en.wikipedia.org/wiki/ACID))
- 외우기 어려우니 약자로 외워야할 것 같다.(= 난 영어가 짜증나서 원일격지 이렇게 외웠다.)

<br>

## 격리수준

> 격리수준은 주로 `조회`시에 수정을 하거나, 또는 다른 행이 추가되는 경우에 대한 내용들이다. `조회` 시에 수정/추가 작업시에 대한 처리 원칙이라는 것을 기억해두자. 나중에 낙관적 락, 비관적 락을 공부하게 되는데, 이 낙관적 락, 비관적 락은  `쓰기` 작업에 대한 처리원칙이다. (용도를 이렇게 구분지어 두고 중간 중간 공부하는 내용을 요약하지 않으면 나중에 낙관적 락/비관적 락이 그냥 잠금이라고만 떠올리는 낭패를 겪게 된다.)

여러개의 트랜잭션은 서로에게 영향을 미치지 않도록 격리될 수 있어야 한다. 트랜잭션을 구현할 때 가장 보장하기 힘든 원칙이 격리성이다. 이런 이유로 ANSI에서는 네가지의 격리수준을 정의하고 있다. 이 네가지 격리수준 중 하나를 선택해서 트랜잭션 로직을 작성할 수 있다면 트랜잭션의 격리성을 만족하는 것이다. 트랜잭션의 격리수준은 아래의 네 가지가 있다.

- `READ UNCOMMITTED (커밋되지 않은 읽기)`
  - 커밋되지 않은 것이라도 읽을 수 있다
  - 읽어들인 커밋되지 않은 데이터가 롤백되면 데이터 정합성에 문제가 생긴다.
  - DIRTY READ 발생
    - t1이 데이터를 수정하고 있는데, 커밋하지 않았는데도 t2가 커밋되지 않은 데이터를 읽어들일 수 있는 현상을 DIRTY READ 라고 한다.
    - 만약 t2가 DIRTY READ 한 데이터를 사용하는데 t1이 수정하고 있던 데이터를 롤백하게 될 경우 데이터 정합성에 문제를 일으키게 된다.
- `READ COMMITTED (커밋된 읽기)`
  - t1이 조회작업을 수행 도중에 t2가 수정/커밋을 했을 경우 t2에 의해 수정/커밋된 버전으로 읽어들인다.
  - NON REPEATABLE READ 가 발생한다.
    - 조회작업를 수행 도중에 새롭게 수정된 데이터를 새롭게 읽어들이므로 매번 같은 데이터를 읽어들일 수 없게된다. 
    - 이렇게 수정/커밋된 데이터에 대해 매번 같은 데이터를 읽어들일 수 없는 현상을 NON REPEATABLE READ 라고 부른다.
- `REPEATABLE READ (반복가능한 읽기)`
  - 위의 READ COMMITED 가 보장하지 못하는 **수정/커밋 된 데이터에 대해 REPEATABLE READ 가 가능하도록 해주는 격리수준**이다.
  - t2가 수정/커밋을 완료된 후에 t1의 조회작업을 마무리하는 것.
  - 즉, 다른 트랜잭션에서 수정/커밋했어도 한번 조회했던 데이터를 반복해서 조회해도 같은 데이터가 조회된다.
  - 하지만 수정/커밋된 데이터가 아닌 **새롭게 추가된 데이터**에 대해서는 반복 조회시 같은 결과값을 조회할 수 있음을 보장하지 못한다.
    - 이런 현상을 PHANTOM READ 라고 이야기한다.
    - 새롭게 유령처럼 뭔가 한 행이 추가되어서 읽혀졌다는 의미
  - (= ex. t2가 수정/커밋이 아닌 추가 작업을 했을 경우는 새롭게 추가된 데이터도 함께 조회결과에 포함되게 되어 반복적으로 읽더라도 같은 결과집합 임을 보장하지는 못한다.) 
- `SERIALIZABLE (직렬화 가능)`
  - 가장 엄격한 트랜잭션 격리수준이다. 
  - PHANTOM READ 조차도 발생하지 않는다.
  - 하지만 동시성 처리 성능이 급격히 떨어질 수 있게 된다.

<br>

### ex) DIRTY READ - READ UNCOMMITTED

- t1이 데이터를 수정하고 있는데, 커밋하지 않았는데도 t2가 커밋되지 않은 데이터를 읽어들일 수 있는 현상을 DIRTY READ 라고 한다.
- 만약 t2가 DIRTY READ 한 데이터를 사용하는데 t1이 수정하고 있던 데이터를 롤백하게 될 경우 데이터 정합성에 문제를 일으키게 된다.

<br>

### ex) NON REPEATABLE READ - READ COMMITTED

트랜잭션 t1 이 회원 A 를 조회 중인데, 갑자기 트랜잭션 t2가 회원 A를 수정하고 커밋하면, 트랜잭션 t1이 다시 회원 A를 조회했을 때 수정된 데이터가 조회된다. DIRTY READ는 허용하지 않는다. 커밋한 데이터만을 읽어들이기 때문이다.

### ex) REPEATABLE READ - PHANTOM READ

트랜잭션 t1이 10살 이하의 회원을 조회했는데 트랜잭션 t2가 5살 회원을 하나 추가하고 커밋하면, 트랜잭션 t1 이 다시 10살 이하의 회원을 조회했을 때 회원 하나가 추가된 상태로 조회된다. 이처럼 반복 조회시 결과 집합이 달라지는 것을 PHANTOM READ라고 한다. (마치 유령처럼 하나의 행이 달라 붙었다. 이런 의미)

### ex) SERIALIZABLE

가장 엄격한 격리수준.
