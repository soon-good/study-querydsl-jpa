# 트랜잭션과 격리수준

> 참고
>
> - [트랜잭션 - ko.wikipedia.org](https://ko.wikipedia.org/wiki/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98)
> - [데이터베이스 트랜잭션 - ko.wikipedia.org](https://ko.wikipedia.org/wiki/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4_%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98)

트랜잭션은 여러가지 분야 또는 여러가지 의미로 쓰인다. 이번 문서에서 정리할 트랜잭션의 개념은 **Database 에 대해 수행하는 한 번의 작업의 논리적 단위**이다. <br>

원래는 작년에 한번 공부했었다. 오늘부터 두번째로 트랜잭션의 격리수준과 락 모드를 다시 정리하면서 공부하고 있는데, 단순히 원칙들을 기억하고 암기하는 것만으로는 정확하게 이해하고 있지 않은 것이라는 것을 깨달은 것 같다. 이론상으로 존재하는 개념들을 실제 애플리케이션의 시스템이 지원가능하도록 하기위해 2차캐시를 이용해 낙관적 락을 사용하거나, 물리적인 Database 레벨에서 비관적 락을 이용해 잠금을 수행하는 등의 작업을 할 수 있다는 것을 약간은 실체적인 개념으로 이해해야 하는 것 같다는 느낌을 받았다. <br>

정리하다보니 낙관적 락, 비관적 락부터 트랜잭션 격리수준 개념까지... 느낀 점은 이렇다. 면접(대기업 ~ 중견)에는 굉장히 자주 나오는 개념이다. 하지만 대부분 이론적인 질문이고 그 내부적인 의미와 실제 적용을 파악한 사람은 적을 수 밖에 없겠다는 생각이 들었다. 최근에 2차 캐시를 실제 hazelcast 클러스터, Ignite 클러스터에 적용하는 방식에 대해 문서를 접했었는데, 실제 경험으로 처음부터 고생하면서 빡시게 직접 구축해보며 경험해본 사람은 정말 손에 꼽을 수밖에 없는 개념일 수도 있겠다는 생각이 들었다.<br>

<br>

## 참고자료

- [트랜잭션 - ko.wikipedia.org](https://ko.wikipedia.org/wiki/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98)
- [데이터베이스 트랜잭션 - ko.wikipedia.org](https://ko.wikipedia.org/wiki/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4_%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98)
- [자바 ORM 표준 JPA 프로그래밍](https://ridibooks.com/books/3984000009)

<br>

## 트랜잭션을 구성하는 기본 원칙 - ACID

트랜잭션은 아래의 네가지 원칙이 보장되어야 한다.

- 원자성(Atomicity)
  - 트랜잭션 내에서 실행한 작업들은 마치 하나의 작업인 것처럼 모두 성공하거나 모두 실패해야 한다.
  - ex) Spring의 @Transactional 에 구현한 내용들에 여러개의 작업단위가 있어도 모두 하나의 작업단위처럼 취급되어서 실패할 경우 해당 작업단위로 롤백된다.
- 일관성(Consistency)
  - 트랜잭션은 데이터베이스의 무결성 제약조건을 항상 만족시켜야 한다.
  - = 모든 트랜잭션은 일관성있는 데이터베이스 상태를 유지해야 한다.
- 격리성(Isolation)
  - 동시에 실행되는 여러개의 트랜잭션들이 서로에게 영향을 미치지 않도록 격리될 수 있어야 한다.
  - 트랜잭션 로직을 구현할 때 가장 보장하기 힘든 원칙이 **격리성**이다. 이런 이유로 ANSI 에서는 네 가지 수준의 격리수준을 정의하고 있다.
  - 이 네 가지 격리 수준 중 하나를 선택해서 트랜잭션 로직을 작성할 수 있다면 트랜잭션의 격리성을 만족하는 것이다.
  - 참고로 격리성을 완벽하게 보장하려면 트랜잭션을 거의 차례대로 수행해야만 한다.
    - 이것을 Serializable 단계라고 하는데, 트래픽이 많은 시스템은 시스템을 느려지게 만들 수 있는 요인이다.
- 지속성(Durability)
  - 트랜잭션을 성공하면 그 결과는 기록되어야 한다.
  - 트랜잭션이 성공했어도 시스템 문제가 발생할 경우, 데이터베이스 로그 등을 이용해 성공한 트랜잭션 내용을 복구할 수 있어야 한다.

<br>

**참고) ACID (Atomicity - Consistency - Isolation - Durability)**<br>

- ACID ([en.wikipedia.org/wiki/ACID](https://en.wikipedia.org/wiki/ACID))
- 외우기 어려우니 약자로 외워야할 것 같다.(= 난 영어가 짜증나서 원일격지 이렇게 외웠다.)

<br>

## 격리수준

여러개의 트랜잭션은 서로에게 영향을 미치지 않도록 격리될 수 있어야 한다. 트랜잭션을 구현할 때 가장 보장하기 힘든 원칙이 격리성이다. 이런 이유로 ANSI에서는 네가지의 격리수준을 정의하고 있다. 이 네가지 격리수준 중 하나를 선택해서 트랜잭션 로직을 작성할 수 있다면 트랜잭션의 격리성을 만족하는 것이다. 트랜잭션의 격리수준은 아래의 네가지가 있다.

- `READ UNCOMMITTED (커밋되지 않은 읽기)`
  - 커밋되지 않은 것이라도 읽을 수 있다
  - DIRTY READ 발생
    - t1이 조회연산 도중에 조금 늦은 시간에 t2가 데이터를 수정/커밋할 경우 t2가 커밋을 안했어도 수정하고 있는 데이터를 그대로 읽어들이게 되는 경우를 DIRTY READ라고 부른다.
- `READ COMMITTED (커밋된 읽기)`
  - t1이 조회작업을 수행 도중에 t2가 수정/커밋을 했을 경우 수정/커밋된 버전으로 읽어들인다.
  - NON REPEATABLE READ 가 발생한다.
    - 조회작업를 수행 도중에 새롭게 수정된 데이터를 새롭게 읽어들이므로 매번 같은 데이터를 읽어들일 수 없게된다. 
    - 이렇게 수정/커밋된 데이터에 대해 매번 같은 데이터를 읽어들일 수 없는 현상을 NON REPEATABLE READ 라고 부른다.
- `REPEATABLE READ (반복가능한 읽기)`
  - 위의 READ COMMITED 가 보장하지 못하는 **수정/커밋 된 데이터에 대해 REPEATABLE READ 가 가능하도록 해주는 격리수준**이다.
  - t2가 수정/커밋을 완료된 후에 t1의 조회작업을 마무리하는 것.
  - 즉, 다른 트랜잭션에서 수정/커밋했어도 한번 조회했던 데이터를 반복해서 조회해도 같은 데이터가 조회된다.
  - 하지만 수정/커밋된 데이터가 아닌 **새롭게 추가된 데이터**에 대해서는 반복 조회시 같은 결과값을 조회할 수 있음을 보장하지 못한다.
    - 이런 현상을 PHANTOM READ 라고 이야기한다.
    - 새롭게 유령처럼 뭔가 한 행이 추가되어서 읽혀졌다는 의미
  - (= ex. t2가 수정/커밋이 아닌 추가 작업을 했을 경우는 새롭게 추가된 데이터도 함께 조회결과에 포함되게 되어 반복적으로 읽더라도 같은 결과집합 임을 보장하지는 못한다.) 
- `SERIALIZABLE (직렬화 가능)`
  - 가장 엄격한 트랜잭션 격리수준이다. 
  - PHANTOM READ 조차도 발생하지 않는다.
  - 하지만 동시성 처리 성능이 급격히 떨어질 수 있게 된다.

<br>

### ex) DIRTY READ - READ UNCOMMITTED

### ex) NON REPEATABLE READ - READ COMMITTED

### ex) REPEATABLE READ - PHANTOM READ

### ex) SERIALIZABLE

