# 낙관적 락과 비관적 락 - 용어 정리

데이터베이스들은 보통 READ COMMITTED 격리수준을 기본으로 사용한다. 이 기본값보다 더 높은 수준의 격리수준이 필요하면 낙관적 락, 비관적 락과 같은 락을 사용한다.<br>

락은 데이터베이스의 트랜잭션이 제공하는 기능이다. JPA 는 DB의 기본 트랜잭션 격리 수준을 `READ COMMITTED` 정도로 가정한다. 만약 일부 로직에 더 높은 격리 수준이 필요하면 낙적락, 비관적 락 둘중 하나를 사용하면 된다.

<br>

## 낙관적 락

- JPA 가 제공하는 버전관리 기능을 사용하는 방식
- 애플리케이션이 제공하는 락
- 트랜잭션 커밋 전까지는 충돌을 알 수 없다. 
- DB에서 제공하는 락이 아니다.

<br>

## 비관적 락

- Ex) select for update
- 락을 걸고 트랜잭션을 시작

<br>

---

언제 한 번 더 정리해야 하는데, 오늘 역시도 시간이 없어서 30분 타이머를 재고 정리중이다. <br>

오늘 역시도 30분만 공부하게 된 데에 대한 변명을 남겨놓으면... 이렇다.(=내일 지울거다.)  오늘 하루 7시 50분까지 출근해서 오후 7시까지 (=저녁 안먹음) 11시간을 스트레이트로 일을 했는데, 결국 누군가의 즉흥적인 생각대로 억지로 따라가야 하게 되어버려서 투입시간 대비 일도 별로 못하고 집에서 또 일을 한다. 요즘 하고 있는 일은 혼자 뭘 열심히 하려 할수록 더 스트레스 받고 성과가 안나오고 있다 요즘. 이렇게 누가 하자는데로 아무렇게나 다 따라다니다가 나중에 뭐 하나 수틀리면 죄다 모두 내 탓으로 뒤집어씌울까봐 무섭다.<br>

어차피 매일같이 집에서 일을 하는 거였지만, 개인 시간(빨래 등등 집안살림, 개인정비)은 점점 줄어들고, 워킹 타임 역시도 점점 뒤로 밀린다. 오늘은 장애가 난거 봐달라, 날짜 타입봐야 하니깐 상용서비스 3시간 꺼보자. 이렇게 해달라는데로 그냥 따라가느라 내 일을 하나도 못했다. 새로운 버전은 그냥 떼어서 붙이면 되는 걸로만 생각하고 있고, 마음이 급한 사람은 나뿐이다. 그냥 FTP로 업로드하면 다되는 줄 아는데 미쳐버릴 정도다. 기존에 안정적으로 동작하고 있는 레거시 타입가져다 써도 시간이 모자른데 왜 이러고 있는지를 모르겠다. 아예 일을 못하고 쌩짜로 시간을 싹다 날렸다.<br>

뭘 마음대로 하지를 못하니 짜증은 치솟고 개발기한은 다가오고... 뭘 하려고 하면 못하게 하면서 또 뭘 개발을 하라고 하니 뭐하라는 건지 당췌모르겠다. 도대체 뭐하자는 건지. 언제 한번 이러다가 참고 참다가 발작버튼 터져서 회사 그만두게 되지 않을까 싶다.<br>

<br>

## 요약

낙관적 락, 비관적 락은 Database 의 트랜잭션이 제공하는 격리수준보다 더 세밀하게 컨트롤할 때 사용하는 방식이다.<br>

`낙관적 락`은 DB에서 제공하는 락이 아니다. 소프트웨어 레벨에서 여러 개의 트랜잭션들이 하나의 데이터를 바라보고 수정할 경우에 대해 데이터에 버전을 매겨서 변경여부를 파악해내는 방식이다. 트랜잭션 커밋 전까지는 충돌을 알 수 없다. JPA에서는 낙관적 락을 버전관리 기능(=영속성 컨텍스트)으로 제공해주고 있다.<br>

`비관적 락` 은 DB에서 제공하는 락이다. 흔히 `select for update` 와 같은 SQL로 사용가능하다. 락을 먼저 걸어두고 데이터를 수정하는 방식이다. 락이 걸리기에 단점이 크지만, 사용해야 하는 경우 역시 존재한다.<br>

<br>

## 두 번의 갱신 분실문제

낙관적 락, 비관적 락을 사용하는 경우를 파악할 때 흔히 다뤄지는 문제는 '두번의 갱신 분실문제'이다. 같은 데이터를 여러 트랜잭션이 바라보고 수정 중일 때 첫번째 트랜잭션의 커밋 만을 인정할지, 마지막 커밋만을 인정할지, 충돌하는 갱신 내용을 병합할지에 대한 내용이 두번의 갱신 분실문제이다. 예를 들면 아래와 같은 경우를 예로 들 수 있다.

> ex) 사용자 A,B 가 동시에 같은 공지사항 게시글을 열어서 수정을 시작했다. 그리고 A가 먼저 수정완료 버튼을 눌렀다.
>
> - 잠시 후 B가 수정 완료를 클릭했다면 A의 수정내용은 분실된다. 즉, 나중에 수정한 B의 내용만 남게 된다.

<br>

이때 아래의 세 가지 방식으로 위의 충돌을 다루는 것이 가능하다.

- 마지막 커밋만 인정하기 (기본 전략)
  - 가장 마지막으로 수정한 글의 버전으로 반영한다.
  - 대부분의 데이터베이스는 마지막 커밋만 인정하기를 사용하고 있는 것으로 보인다.
- 최초 커밋만 인정하기
  - JPA 가 제공하는 버전 관리 기능(낙관적 락을 위해 제공해주는 JPA의 영속성 컨텍스트)을 이용해 손쉽게  `최초 커밋만 인정하기` 를 구현할 수 있다.
- 충돌하는 갱신 내용 병합하기
  - 최초 커밋만 인정하기 방식을 조금 더 우아하게 처리하는 방식이다.
  - 애플리케이션 개발자가 직접 사용자를 위한 병합 방법을 제공해야 한다. 
  - 예를 들면 위의 공지사항과 같은 서비스의 경우는 diff 등의 기능을 이용해서 병합시의 충돌을 병합하는 기능을 사용자에게 제공해주기도 하고, 병합시 스마트 머지가 가능하도록 UI 레벨에서 제공하는 방식으로도 해결가능하다.

<br>













