# 낙관적 락과 비관적 락 - 용어 정리

데이터베이스들은 보통 READ COMMITTED 격리수준을 기본으로 사용한다. 이 기본값보다 더 높은 수준의 격리수준이 필요하면 낙관적 락, 비관적 락과 같은 락을 사용한다.<br>

락은 데이터베이스의 트랜잭션이 제공하는 기능이다. JPA 는 DB의 기본 트랜잭션 격리 수준을 `READ COMMITTED` 정도로 가정한다. 만약 일부 로직에 더 높은 격리 수준이 필요하면 낙적락, 비관적 락 둘중 하나를 사용하면 된다.

<br>

## 낙관적 락

- JPA 가 제공하는 버전관리 기능을 사용하는 방식
- 애플리케이션이 제공하는 락
- 트랜잭션 커밋 전까지는 충돌을 알 수 없다. 
- DB에서 제공하는 락이 아니다.

<br>

## 비관적 락

- Ex) select for update
- 락을 걸고 트랜잭션을 시작

<br>

## 요약

낙관적 락, 비관적 락은 Database 의 트랜잭션이 제공하는 격리수준보다 더 세밀하게 컨트롤할 때 사용하는 방식이다.<br>

`낙관적 락`은 DB에서 제공하는 락이 아니다. 소프트웨어 레벨에서 여러 개의 트랜잭션들이 하나의 데이터를 바라보고 수정할 경우에 대해 데이터에 버전을 매겨서 변경여부를 파악해내는 방식이다. 트랜잭션 커밋 전까지는 충돌을 알 수 없다. JPA에서는 낙관적 락을 버전관리 기능(=영속성 컨텍스트)으로 제공해주고 있다.<br>

`비관적 락` 은 DB에서 제공하는 락이다. 흔히 `select for update` 와 같은 SQL로 사용가능하다. 락을 먼저 걸어두고 데이터를 수정하는 방식이다. 락이 걸리기에 단점이 크지만, 사용해야 하는 경우 역시 존재한다.<br>

<br>

## 두 번의 갱신 분실문제

낙관적 락, 비관적 락을 사용하는 경우를 파악할 때 흔히 다뤄지는 문제는 '두번의 갱신 분실문제'이다. 같은 데이터를 여러 트랜잭션이 바라보고 수정 중일 때 첫번째 트랜잭션의 커밋 만을 인정할지, 마지막 커밋만을 인정할지, 충돌하는 갱신 내용을 병합할지에 대한 내용이 두번의 갱신 분실문제이다. 예를 들면 아래와 같은 경우를 예로 들 수 있다.

> ex) 사용자 A,B 가 동시에 같은 공지사항 게시글을 열어서 수정을 시작했다. 그리고 A가 먼저 수정완료 버튼을 눌렀다.
>
> - 잠시 후 B가 수정 완료를 클릭했다면 A의 수정내용은 분실된다. 즉, 나중에 수정한 B의 내용만 남게 된다.

<br>

이때 아래의 세 가지 방식으로 위의 충돌을 다루는 것이 가능하다.

- 마지막 커밋만 인정하기 (기본 전략)
  - 가장 마지막으로 수정한 글의 버전으로 반영한다.
  - 대부분의 데이터베이스는 마지막 커밋만 인정하기를 사용하고 있는 것으로 보인다.
- 최초 커밋만 인정하기
  - JPA 가 제공하는 버전 관리 기능(낙관적 락을 위해 제공해주는 JPA의 영속성 컨텍스트)을 이용해 손쉽게  `최초 커밋만 인정하기` 를 구현할 수 있다.
- 충돌하는 갱신 내용 병합하기
  - 최초 커밋만 인정하기 방식을 조금 더 우아하게 처리하는 방식이다.
  - 애플리케이션 개발자가 직접 사용자를 위한 병합 방법을 제공해야 한다. 
  - 예를 들면 위의 공지사항과 같은 서비스의 경우는 diff 등의 기능을 이용해서 병합시의 충돌을 병합하는 기능을 사용자에게 제공해주기도 하고, 병합시 스마트 머지가 가능하도록 UI 레벨에서 제공하는 방식으로도 해결가능하다.

<br>







