# 스프링이 트랜잭션 기능을 제공하는 방식들

제품을 개발하는 개발자들은 대부분 DB에 종속적으로 개발한다. 하지만, 비용문제, 기술지원문제, 인프라문제, 유지보수 문제 등등 어떠한 문제로든 DB를 변경해야만 하는 경우 역시 발생한다. 꼭 이런 경우를 가정해서 트랜잭션에 대한 개념을 정리하려고 하는 것은 아니다.<br>

스프링의 PlatformTransactionManager 를 구체화한 여러개의 클래스와, 이것들에 동기화 개념은 어떻게 적용되어있는지, 템플릿화는 어떻게 하고, 결국 `@Transactional` 이 스프링에서 사용되게 된 필요성은 무엇인지 정리한다. 김영한 님의 강의를 보고 공부를 했는데, 시간도 많이 들이셨을것 같고, 내부 소스도 모두 직접 파악하고, 예제를 직접 떠올려서 만드시는 것만 해도 시간을 많이 들이셨겠구나 하는 생각이 들었다.<br>

직접 공부를 하다보니,  예제를 직접 돌려봐야 트랜잭션 코드를 어떤 필요에 의해 추상화했고, 템플릿화를 왜 했는지, `@Transactional` 이 등장하게 된 계기는 뭔지 등에 대해 이해되는 것 같다. 아직은 프린트만 일단 보고 있다. 실제 강의는 하루 날 잡아서 완주해야겠다하고 생각중이다.<br>

실제 수업 프린트는 내가 적어놓은 설명에 비해 더 자세하고, 더 좋은 내용이 많다. 나는 그저 얕은 부분의 스토리만을 요약해두었을뿐.<br>

<br>

# 참고자료

- [스프링 DB 1편 - 데이터 접근 핵심 원리 대시보드 - 인프런 | 강의 (inflearn.com)](https://www.inflearn.com/course/스프링-db-1/dashboard)

혹시라도 내 깃헙을 보고 공부하는 사람들이 있을지는 모르겠지만, 혹시라도 있을 경우도 있기에, 자세한 내용은 강사님의 강의를 봐야만 이해가 가게끔 최대한 요약만 해둘 예정이다. 내 글은 그냥 요약정리 프린트처럼만 만들어놓을 예정<br>

그냥 노트에 필기해둔대로 두기에는, 백업이 너무 안되기에 결국 정리를 시작했다.<br>

이직을 하고 생활이 안정되면, 깃랩으로 모든 코드를 옮겨버리고 비공개로 전환하든가 해야할 것 같다.<br>

조금 불안하다 싶으면 바로 비공개로 전환할 예정.<br>

요즘 몰상식한 사람들이 너무 많아서... 내가 알아서 조심을 해야하는 것 같다.<br>

<br>

# 요약

요약해둘 내용은 아래와 같다.

- 트랜잭션 추상화
- 트랜잭션 동기화
- 트랜잭션 템플릿
  - jdbc commit/rollback
- 트랜잭션 리소스 초기화/회수 코드 분리
  - 선언적방식 : `@Transactional` 
  - AOP 를 사용한 로직 직접 구현
  - 프로그래밍 방식

<br>

# 트랜잭션 추상화

> Transaction 을 얻어오는 코드는 각 JDBC 추상화라이브러리마다 다르다. 스프링을 사용하면, `PlatformTrasactionManager` 을 통해서 어떤 JDBC 구체 라이브러리를 사용하든 `PlatformTranansactionManager` 타입에서 제공하는 메서드로 Transaction 객체를 얻어올 수 있다. <br>
>
> PlatformTransactionManager 는 아래의 메서드들을 제공한다.
>
> - getTransaction(TransactionDefinition) : TransactionStatus
> - commit(TransactionStatus) : void
> - rollback(TransactionStatus) : void
>
> Transaction 을 얻어오는 로직(=getTransaction(T))외에도 커밋(commit), 롤백(rollback) 역시도 `PlatformTransactionManager` 타입으로 어떤 JDBC 구체 라이브러리든 `commit(TransactionStatus) : void` , `rollback(TransactionStataus) : void` 를 통해 접근 가능하다.<br>
>
> 이렇게 다른 JDBC 구현 라이브러리를 사용하더라도 같은 타입인 `PlatformTrasactionManager`를 이용해 모두가 같은 메서드 들인 `getTranaction`, `commit`, `rollback` 을 사용하도록 공통화가 된다는 것은 장점이다. 이것에 대해서는 김영한님의 강의헤서는 **트랜잭션 추상화** 라는 개념으로 설명하고 있다.

<br>

JDBC 추상화 라이브러리(순수 JDBC 코드, JPA, Mybatis, QueryDSL, JOOQ 등등)마다 Transaction 획득, Transaction begin, end 처리, commit 처리를 하는 Java 코드는 다르다.<br>

만약 하나의 애플리케이션 내에서 여러 개의 라이브러리를 혼용해서 사용해야 하는 경우 Transaction 을 얻어올때 각 JDBC 추상화 라이브러리에 따라 다르게 구현된다.<br>

이렇게 JDBC 접근 코드가 데이터접근 코드마다 달라질 경우에 생각할 수 있는 가장 쉬운 방법은 `TxManager` 같은 클래스를 만들어서, 각 DB마다 다른 동작을 하도록 하는 클래스들을 만들어두는 것이다. 스프링은 이런 `TxManager` 클래스 같은 역할을 하는 `PlatformTransactionManager`라는 interface 를 제공하는데, `PlatformTransactionManager` 를 implments 한 클래스 들 중 원하는 클래스를 선택해서 인스턴스화 하는 Bean을 생성해서 등록해 사용할 수 있도록 해준다.<br>

PlatformTransactionManager는 아래와 같은 기능을 제공해주고 있다.

```java
public interface PlatformTransactionManager extends TransactionManager {
    TransactionStatus getTransaction(@Nullable TransactionDefinition definition)
			throws TransactionException;
    void commit(TransactionStatus status) throws TransactionException;
    void rollback(TransactionStatus status) throws TransactionException;
}
```

<br>

이런 `PlatformTrasactionManager` 라는 interface 를 `implements` 한 클래스로는 대표적으로 아래의 클래스들 이 있다.

- `DataSourceTransctionManager` 
- `JdbcTransactionManager`
- `JpaTransactionManager` 
- `EtcTrasactionManager`

<br>

스프링에서는 이렇게 `implements` 한 트랜잭션 매니저 클래스 들 중 하나를 선택해서 인스턴스화 하고 이것을 Bean 으로 등록해서 사용할수 있다.<br>

단순한 예제기반의 요약본은 추후 다른 문서에 정리 예정이다.<br>

<br>

# 트랜잭션 동기화

트랜잭션은 동기화가 필요하다. 스프링에서 제공하는 `PlatformTrasactionManager` 는 트랜잭션 동기화 매니저를 제공해주고 있다.

스프링에서 제공하는 각각의 `PlatformTransactionManager` 클래스를 implmenets 하는 각각의 구체 타입들은 내부적으로 트랜잭션 동기화 매니저클래스인 `TransactionSyncronizationManager` 를 이용해 트랜잭션을 얻는 과정을 동기화 한다.<br>

자세한 내용은 `TheadLocal` 을 통해 구현되어있다고 한다.<br>

즉, `DataSourceTransactionManager` , `JdbcTransactionManager`, `JpaTransactionManager`, `EtcTransactionManager` 등은 각각의  클래스 내부에서 `TransactionSyncronizationManager` 클래스를 사용한다.<br>

내부적으로 트랜잭션 동기화 매니저를 사용해 동기화를 수행하게끔 되어 있으므로, 사용자는 트랜잭션 동기화에 크게 신경쓰지 않아도 된다.<br>

**나머지 내용(UML)은 추후 정리 예정**<br>

`DataSourceTransactionManager` 클래스테서 동기화 매니저를 사용하는 부분을 살펴보자.

```java
public class DataSourceTransactionManager extends AbstractPlatformTransactionManager
		implements ResourceTransactionManager, InitializingBean {
    
    // ...

    @Override
	protected Object doGetTransaction() {
		DataSourceTransactionObject txObject = new DataSourceTransactionObject();
		txObject.setSavepointAllowed(isNestedTransactionAllowed());
		ConnectionHolder conHolder =
				(ConnectionHolder) TransactionSynchronizationManager.getResource(obtainDataSource());
		txObject.setConnectionHolder(conHolder, false);
		return txObject;
	}
    
    // ...
}
```

`TransactionSynconizationManager` 를 통해서 `ConnectionHolder` 를 얻고 있다.<br>

이번에는 `JpaTransactionManager` 클래스 내에서 동기화 매니저를 사용하는 부분을 살펴보자.<br>

```java
public class JpaTransactionManager extends AbstractPlatformTransactionManager
		implements ResourceTransactionManager, BeanFactoryAware, InitializingBean {
    
    // ...
    
    @Override
	protected Object doGetTransaction() {
		JpaTransactionObject txObject = new JpaTransactionObject();
		txObject.setSavepointAllowed(isNestedTransactionAllowed());

		EntityManagerHolder emHolder = (EntityManagerHolder)
				TransactionSynchronizationManager.getResource(obtainEntityManagerFactory());
		if (emHolder != null) {
			if (logger.isDebugEnabled()) {
				logger.debug("Found thread-bound EntityManager [" + emHolder.getEntityManager() +
						"] for JPA transaction");
			}
			txObject.setEntityManagerHolder(emHolder, false);
		}

		if (getDataSource() != null) {
			ConnectionHolder conHolder = (ConnectionHolder)
					TransactionSynchronizationManager.getResource(getDataSource());
			txObject.setConnectionHolder(conHolder);
		}

		return txObject;
	}
    
    // ...
    
}
```

<br>

# 트랜잭션 템플릿

Transaction 객체는 PlatformTransactionManager 를 이용해서 얻어올 수 있게 됐다. 그리고 `PlatformTransactionManager` 객체를 기반으로 통일된 기능인 `commit`, `rollback` , `getTransaction` 은 `PlatformTransactionManager` 객체로 접근 가능하다.<br>

DB를 호출하는 단위를 논리적으로 묶어서, 해당 작업에 오류가 있을 때 롤백하는 것은 보통 서비스 계층에서 이루어진다. 데이터 계층에 비즈니스로직을 넣어두어서 트랜잭셔널 하게 구성하는 것은 좋지 않은 방식이다. 데이터 계층은 데이터 접근 기술 자체로만 순수하게 구성되는 것이 낫다.<br>

즉, 위와 같이 트랜잭션을 수행하는 getTranaction, commit, rollback 을 하는 코드들은 어느 정도 공통화/추상화가 되었다. 그런데, 이 getTransaction, commit, rollback은 항상 서비스 계층 코드에서 반복해서 작성하게 된다. 이런 반복적인 코드를 줄일 수 있는 방법은 없을까? 이것은 TransactionTemplate 으로 해결 가능하다.

<br>

오늘은 시간이 좀 부족해서 나중에 다시 정리 예정

<br>

# 트랜잭션 리소스 초기화/회수 코드 분리

- 트랜잭션 리소스 초기화/회수 코드 분리
  - 선언적 방식
    - `@Transactional` 
  - AOP 를 사용한 로직 직접 구현
  - 프로그래밍 방식 
    - 테스트코드에서 트랜잭션을 검증할 때 사용
    - 자세한 내용은 스티브 프리드먼의 객체지향 설계와 실천 이라는 책에서도 언급되고 있다.

<br>



