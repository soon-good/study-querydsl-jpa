# 스프링이 트랜잭션 기능을 제공하는 방식들

> 처음 문서를 작성할 때는 나 조차도 어떻게 글을 써야 할지 막막해서 이것저것 다 쓰느라 글이 꽤 지저분했는데, 일주일 동안 다른 취준공부 등을 하느라 생각을 접어뒀었는데, 그 동안 뇌가 치유의 과정을 겪었나보다. <br>
>
> 오늘 트랜잭션 템플릿을 정리하면서, 어떻게 요약할지 조금 감이 잡히기 시작했다. 역시 초본은 깨끗하지 않다. 지속적으로 다듬어야 한다.<br>

<br>

# 참고자료

- [스프링 DB 1편 - 데이터 접근 핵심 원리 대시보드 - 인프런 | 강의 (inflearn.com)](https://www.inflearn.com/course/스프링-db-1/dashboard)
- [16. Transaction Management](https://docs.spring.io/spring-framework/docs/4.2.x/spring-framework-reference/html/transaction.html)
- [PlatformTransactionManager (Spring Framework 5.3.20 API)](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/PlatformTransactionManager.html)
- [JdbcTransactionManager (Spring Framework 5.3.20 API)](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/jdbc/support/JdbcTransactionManager.html) 
- [DataSourceTransactionManager (Spring Framework 5.3.20 API)](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/jdbc/datasource/DataSourceTransactionManager.html)
- [JpaTransactionManager (Spring Framework 5.3.20 API)](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/orm/jpa/JpaTransactionManager.html)

<br>

# 요약

요약해둘 내용은 아래와 같다.

- 트랜잭션 추상화
- 트랜잭션 동기화
- 트랜잭션 템플릿
  - jdbc commit/rollback
- 트랜잭션 리소스 초기화/회수 코드 분리
  - 선언적방식 : `@Transactional` 
  - AOP 를 사용한 로직 직접 구현
  - 프로그래밍 방식

<br>

# 트랜잭션 추상화 (feat. PlatformTransactionManager)

> **스프링이 제공하는 JDBC 라이브러리 종류별 구현체 라이브러리**<br>

스프링은 데이터 라이브러리마다 다른 Transaction 을 얻어오는 동작, Transaction begin/end, commit, rollback 동작들을 공통적인 3가지의 메서드로 분류해서, 각 라이브러리로 구현하도록 하는 유연한 방식으로 TrnasactionManager 기능을 제공하고 있다.<br>

그리고 JDBC 기능 구현체마다 다른 트랜잭션 관련된 구체 기능이 구현된 트랜잭션 매니저들은 스프링에서 아래의 구체클래스들로 제공해주고 있다.

- JDBCTemplate : DataSourceTransactionManager, JdbcTransactionManager
  - [DataSourceTransactionManager (Spring Framework 5.3.20 API)](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/jdbc/datasource/DataSourceTransactionManager.html)
  - [JdbcTransactionManager (Spring Framework 5.3.20 API)](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/jdbc/support/JdbcTransactionManager.html) 
- JPA : JpaTransactionManager
  - [JpaTransactionManager (Spring Framework 5.3.20 API)](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/orm/jpa/JpaTransactionManager.html)
- Etc : EtcTransactionManager

<br>

> **만약 스프링의 도움 없이 스프링이 제공하는 TransactionManager 기능을 사용하려면?**<br>

이렇게 스프링 데이터에서 기본으로 제공되는 구체클래스들을 스프링 프레임워크의 도움 없이 직접 프로그램 내에서 인스턴스를 생성하고, JAVA 프로그램을 구현한다고 해보자. 그리고 이 프로그램은 JDBCTemplate, JPA, Etc 라이브러리를 모두 사용한다.<br>

이런 경우 가장 쉽게 생각할 수 있는 것은 `TxManager` 라고 부르는 클래스를 만들어서 이 안에서 구현체 라이브러리마다 다른 동작을 수행할 수 있도록 하는 메서드를 제공하도록 구현하게 될 것이다. 예를 들면 아래 그림과 같은 방식으로 구현하게 될 것이다.<br>

<br>

![1](./img/TRANSACTION-MANAGER-1.png)

<br>

> **스프링을 이용해 JDBC 종류별 TransactionManager를 여러 개 생성해 사용하려면?**<br>

스프링은  JDBC 구현체 라이브러리마다 각각 다른 코드들에 대해 PlatformTrasactionManager 타입으로 의존성을 주입받을 수 있도록 PlatformTransactionManager 라는 인터페이스를 제공하고 있다. 그리고, JPA, JDBC,Mybatis 와 같은 JDBC를 구현한 데이터접근 라이브러리들은 PlatformTransactionManager 를 implements 하고 있다.

![1](./img/TRANSACTION-MANAGER-2.png)

<br>

예를 들면 JPATransactionManager 객체를 생성할 경우 아래와 같이 스프링 컨테이너에 빈으로 등록해서 사용한다. (참고 : [Spring Data JPA - Reference Documentation](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.java-config) )

```java
@Configuration
@EnableJpaRepositories
@EnableTransactionManagement
class ApplicationConfig {

  @Bean
  public DataSource dataSource() {

    EmbeddedDatabaseBuilder builder = new EmbeddedDatabaseBuilder();
    return builder.setType(EmbeddedDatabaseType.HSQL).build();
  }

  @Bean
  public LocalContainerEntityManagerFactoryBean entityManagerFactory() {

    HibernateJpaVendorAdapter vendorAdapter = new HibernateJpaVendorAdapter();
    vendorAdapter.setGenerateDdl(true);

    LocalContainerEntityManagerFactoryBean factory = new LocalContainerEntityManagerFactoryBean();
    factory.setJpaVendorAdapter(vendorAdapter);
    factory.setPackagesToScan("com.acme.domain");
    factory.setDataSource(dataSource());
    return factory;
  }

  @Bean
  public PlatformTransactionManager transactionManager(EntityManagerFactory entityManagerFactory) {

    JpaTransactionManager txManager = new JpaTransactionManager();
    txManager.setEntityManagerFactory(entityManagerFactory);
    return txManager;
  }
}
```

<br>

이 외에도 JDBCTemplate, Mybatis 와 같은 JDBC 라이브러리에 대한 트랜잭션 매니저 인스턴스 객체도 위와 같은 방식으로 PlatformTransactionManager 타입으로 스프링 컨테이너에 등록해두면 된다.<br>

<br>

`PlatformTransactionManager` 인터페이스는 아래와 같은 모양이다.

```java
public interface PlatformTransactionManager extends TransactionManager {
    TransactionStatus getTransaction(@Nullable TransactionDefinition definition)
			throws TransactionException;
    void commit(TransactionStatus status) throws TransactionException;
    void rollback(TransactionStatus status) throws TransactionException;
}
```

<br>

이런 `PlatformTrasactionManager` 라는 interface 를 `implements` 한 클래스로는 대표적으로 아래의 클래스들 이 있다.

- `DataSourceTransctionManager` 
- `JdbcTransactionManager`
- `JpaTransactionManager` 
- `EtcTrasactionManager`

<br>

![1](./img/TRANSACTION-MANAGER-3.png)

스프링에서는 이렇게 `implements` 한 트랜잭션 매니저 클래스 들 중 하나를 선택해서 인스턴스화 하고 이것을 Bean 으로 등록해서 사용할수 있다.<br>

<br>

# 트랜잭션 동기화 매니저 (feat. TransactionSynchronizationManager)

트랜잭션은 동기화가 필요하다. 스프링에서 제공하는 `PlatformTrasactionManager` 는 트랜잭션 동기화 매니저를 제공해주고 있다.<br>

스프링에서 제공하는 각각의 `PlatformTransactionManager` 클래스를 implmenets 하는 각각의 구체 타입들은 내부적으로 트랜잭션 동기화 매니저클래스인 `TransactionSyncronizationManager` 를 이용해 트랜잭션을 얻는 과정을 동기화 한다.(자세한 내용은 `TheadLocal` 을 통해 구현되어있다고 한다.)<br>

즉, `DataSourceTransactionManager` , `JdbcTransactionManager`, `JpaTransactionManager`, `EtcTransactionManager` 등은 각각의  클래스 내부에서 `TransactionSyncronizationManager` 클래스를 사용한다.<br>

JDBC 라이브러리 별로 각각의 라이브러리 내부에서 트랜잭션 동기화는, 각 라이브러리 내에서 내부적으로 트랜잭션 동기화 매니저(`TransactionSynchronizationManager`)를 사용해 동기화를 수행하게끔 되어 있으므로, 사용자는 트랜잭션 동기화에 크게 신경쓰지 않아도 된다.<br>

각 구현체의 구체적인 소스코드의 동작을 간단하게 요약해보면 이렇다.<br>

JDBC<br>

- TransactionSynchronizationManager 클래스의 getResource(Datasource) 메서드를 통해 `ConnectionHolder` 타입의 객체를 얻는다.

JPA<br>

- TransactionManager 클래스의 getResource(DataSource) 메서드를 통해 `ConnectionHolder` 타입의 객체를 얻는다.
- 다만, JPA 의 경우 EntityManagerHolder 타입으로 다운캐스팅한다. 아마도 EntityManagerHolder 의 경우 JPA 에서만 제공해주는 기능이 있기에 그렇지 않을까 싶다.

<br>

> `0000Holder` <br>
>
> 스프링 시큐리티에도 보면 SecurityContextHolder 라는 클래스가 있다. 스프링의 jdbc 에서도 비슷하게 ConnectionHolder 라는 클래스를 제공해주고 있다. Connection을 제공해주는 역할을 한다. 스프링에서는 Connection 을 잡고 있거나, Authentication 문맥을 잡고 있는 등의 역할을 하는 것을 보통 접미사로 `-Holder` 를 사용한다.<br>

<br>

**나머지 내용(UML)은 추후 정리 예정**<br>

<br>

### (JDBC) DataSourcTransactionManager 에서의 동기화 매니저

`DataSourceTransactionManager` 클래스에서 동기화 매니저를 사용하는 부분을 살펴보자.

```java
public class DataSourceTransactionManager extends AbstractPlatformTransactionManager
		implements ResourceTransactionManager, InitializingBean {
    
    // ...

    @Override
	protected Object doGetTransaction() {
		DataSourceTransactionObject txObject = new DataSourceTransactionObject();
		txObject.setSavepointAllowed(isNestedTransactionAllowed());
		ConnectionHolder conHolder =
				(ConnectionHolder) TransactionSynchronizationManager.getResource(obtainDataSource());
		txObject.setConnectionHolder(conHolder, false);
		return txObject;
	}
    
    // ...
}
```

<br>

`TransactionSynconizationManager` 를 통해서 `ConnectionHolder` 를 얻고 있다.<br>

> ConnectionHolder conHolder = (ConnectionHolder) TransactionSynchronizationManager.getResource(obtainDataSource());

<br>

### (Jpa) JpaTransactionManager 에서의 동기화 매니저

이번에는 `JpaTransactionManager` 클래스 내에서 동기화 매니저를 사용하는 부분을 살펴보자.<br>

```java
public class JpaTransactionManager extends AbstractPlatformTransactionManager
		implements ResourceTransactionManager, BeanFactoryAware, InitializingBean {
    
    // ...
    
    @Override
	protected Object doGetTransaction() {
		JpaTransactionObject txObject = new JpaTransactionObject();
		txObject.setSavepointAllowed(isNestedTransactionAllowed());

		EntityManagerHolder emHolder = (EntityManagerHolder)
				TransactionSynchronizationManager.getResource(obtainEntityManagerFactory());
		if (emHolder != null) {
			if (logger.isDebugEnabled()) {
				logger.debug("Found thread-bound EntityManager [" + emHolder.getEntityManager() +
						"] for JPA transaction");
			}
			txObject.setEntityManagerHolder(emHolder, false);
		}

		if (getDataSource() != null) {
			ConnectionHolder conHolder = (ConnectionHolder)
					TransactionSynchronizationManager.getResource(getDataSource());
			txObject.setConnectionHolder(conHolder);
		}

		return txObject;
	}
    
    // ...
    
}
```

<br>

`TransactionSychronizationManager` 를 통해서 EntityManagerHolder 를 얻은 후에 이후의 동작을 수행한다.

> EntityManagerHolder emHolder = (EntityManagerHolder) TransactionSynchronizationManager.getResource(obtainEntityManagerFactory());

<br>

# 트랜잭션 템플릿

**TransactionTemplate 을 이용해 commit, rollback 메서드 실행로직 공통화**<br>

스프링에서는 TransactionTemplate 클래스를 제공하고 있다. 이 TransactionTemplate 클래스를 사용하면 commit, rollback을 모든 코드에 일일이 적어주는 대신 execute, executeWithoutResult 등의 메서드를 이용해, commit, rollback 코드의 실행은 TransactionTemplate 객체가 수행하도록 할 수 있다.<br>

TransactionTemplate 클래스가 상속하는 클래스인 TransactionDefinition 클래스, implements 하고 있는 interface인 TransactionOperation 인터페이스의 구조는 아래와 같다.(그림 참고)<br>

<br>

![1](./img/TRANSACTION-TEMPLATE-1.png)

<br>

TransactionTemplate 클래스는 TransactionOperations 인터페이스를 implements하고 있다. 그리고 TransactionOperations 인터페이스를 통해 execute(), executeWitoutResult() 메서드를 사용할 수 있다.<br>

> [TransactionTemplate (Spring Framework 5.3.21 API)](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/support/TransactionTemplate.html) <br>

<br>

**TrasnactionOperations 인터페이스**<br>

위에서 정리한 그림에 나타난 클래스/인터페이스 중에서 오늘 살펴볼 클래스는 TransactionOperations 인터페이스다.

TransactionOperations 인터페이스에서 제공하는 메서드는 아래와 같다.<br>

execute, executeWithoutResult, withoutTransaction 등의 메서드를 제공하고 있다.<br>

그리고 이것은 구현체인 TransactionTemplate 클래스에서 execute, executeWithoutResult 클래스 내에서 구현해야 한다.<br>

아래는 TransactionOperations 라는 인터페이스의 실제 코드를 발췌해온 코드다.

```java
public interface TransactionOperations {
	@Nullable
	<T> T execute(TransactionCallback<T> action) throws TransactionException;
    
	default void executeWithoutResult(Consumer<TransactionStatus> action) throws TransactionException {
		execute(status -> {
			action.accept(status);
			return null;
		});
	}
    
	static TransactionOperations withoutTransaction() {
		return WithoutTransactionOperations.INSTANCE;
	}
}
```

<br>

각 메서드를 간단하게 요약해서 정리해봤다.

**execute**<br>

- 참고 : [TransactionCallback (Spring Framework 5.3.20 API)](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/support/TransactionCallback.html) 
- commit, rollback 을 수행하는 역할을 한다. 
- 이때 commt, rollback 은 TransactionOperation 객체가 수행해주고, commit, rollback 사이에 수행할 비즈니스 로직은 라이브러리 사용자(=개발자)로부터 `TransactionCallback` 인스턴스로 인자로 받아서 수행한다.

<br>

**executeWithoutResult**<br>

- 참고 : [TransactionOperations](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/support/TransactionOperations.html)
- commit, rollback을 수행하는 역할을 한다.
- 이때 commit, rollback 은 TransactionOperation 객체가 수행해주고 commit, rollback 사이에 수행할 비즈니스 로직은 라이브러리 사용자(=개발자)로부터 `Consumer<TransactionStatus>` 인스턴스를 전달받아서 수행한다.<br>

<br>

**예제 시나리오 - TransactionTemplate 도입 Before/After 비교**<br>

예를 들어 JDBC 로직을 작성한다고 해보자. JdbcTransactionManager 타입의 인스턴스를 생성해서 빈으로 등록해두고, PlatformTransactionManager 타입으로 받아온 후에 일련의 처리 로직을 거치게 된다.<br>

이때 여전히 commit(), rollback() 코드가 Service 계층에도 남아있게 된다. 이렇게 되는 이유는 commit, rollback 하는 시점은 DB계층이 아닌 논리적 계층인 Service 계층에서 커밋/롤백의 단위를 논리적으로 구분해두어야 하기 때문이다.<br>

이렇게 여기저기 산재해있는 commit, rollback 코드는 TransactionTemplate 객체를 사용해 공통화할 수 있다. 

트랜잭션 템플릿은, commit, rollback 과 같은 로직은 execute(), executeWitoutResult() 와 같은 메서드 내에서 수행하고 비즈니스 로직은 `Consumer<TransactionStatus>` , `TransactionCallback<T>` 를 받아서 처리하도록 하는 역할을 수행할 수 있도록 해준다.<br>

<br>

물론 이렇게 해도 아직은 DB계층을 서비스 코드에서 아직까지는 완전히 제거하지 못한다. TransactionTemplate 틀 여전히 서비스 코드에 의존성으로 존재하기 때문이다. 가급적이면 DB에 관련된 동작은 DB계층에 대해 독립적으로 코드가 구현되어야, 테스트시에도 경계를 명확히 구분지을 수 있다는 점에서 아직까지는 불편한 코드다.<br>

<br>

이제 예제를 한번 보자.<br>

<br>

## (Before) TransactionTemplate 도입 전

>  **PostService.java**

PostJdbcDao 라는 객체를 의존성 주입받아서 사용하고 있다. 코드를 자세히 살펴보면, commit, rollback 코드가 있다. 이렇게 하면, commit, rollback 메서드가 여기 저기에 존재하게 된다.<br>

```java
@Service
public class PostService{
    
    private final PostJdbcDao postJdbcDao;
    
    public PostService(PostJdbcDao postJdbcDao){
        this.postJdbcDao = postJdbcDao;
    }
    
    public void modifyPost(PostDto postDto){
        TransactionStatus status = transactionManager.getTransaction(new DefaultTransactionDefinition());
        
        try{
	        postJdbcDao.updatePost(postDto);          
            transactionManager.commit(status);
        }
        catch(Exception e){
            transactionManager.rollback(status);
        }

    }
    
}
```

<br>

> **PostJdbcDaoImpl.java**

JDBCTemplate 코드다. 특별한 점은 없다. DB 기술계층의 코드이다.<br>

(version 필드를 두어서 optimistic 락을 하게끔 흉내를 냈는데, 여기에 대해서는 다른 문서에서 정리 예정이다.)<br>

```java
@Component
public class PostJdbcDaoImpl implements PostDao{
    private final JdbcTemplate jdbcTemplate;
    public PostJdbcDao(DataSource dataSource){
        this.jdbcTemplate = new JdbcTemplate(dataSource);
    }
    
    @Override
    public void update(PostDto postDto){
        StringBuilder builder = new StringBuilder();
        builder.append("update Post set content = ?, version = ? where id = ?");
        jdbcTemplate.update(builder.toString(), postDto.getId(), postDto.getVersion()+1, postDto.getId());
    }
}
```

<br>

자세히 보면 아래와 같은 로직이 `@Service` 로직에 남아있다. execute와 commit 을 Service 계층에서 물리적으로 수행하고 있다.

```java
    public void modifyPost(PostDto postDto){
        TransactionStatus status = transactionManager.getTransaction(new DefaultTransactionDefinition());
        
        try{
	        postJdbcDao.updatePost(postDto);          
            transactionManager.commit(status);
        }
        catch(Exception e){
            transactionManager.rollback(status);
        }

    }
```

모든 서비스코드마다 이렇게 commit, rollback 로직이 남아있게 된다. <br>

위에서 요약해두었듯이 스프링에서는 TransactionTemplate 이라는 인터페이스를 제공하고 있다. 트랜잭션 템플릿은, commit, rollback 과 같은 로직은 execute(), executeWithoutResult() 와 같은 메서드 내에서 수행하고 비즈니스 로직은 `Consumer<TransactionStatus>` , `TransactionCallback<T>` 를 받아서 처리하도록 하는 역할을 수행한다.<br>

<br>

## (After) TransactionTemplate 도입 후

위의 코드와 비교했을 때 달라지는 부분은 서비스측의 코드다. 코드를 보자.

```java
@Service
public class PostService{
    private final PostJdbcDao postJdbcDao;
    private final TransactionTemplate transactionTemplate;
    
    public PostService(
        PlatformTransactionManager transactionManager,
        PlatPostJdbcDao postJdbcDao
    ){
        this.transactionManager = new TransactionTemplate(transactionManager);
        this.postJdbcDao = postJdbcDao;
    }
    
    public void modifyPost(PostDto postDto){
        transactionTemplate.executeWithoutResult((stats)->{
           try{
               postJdbcDao.updatePost(postDto);
           } 
           catch(Exception e){
               e.printStackTrace();
           }
        });
    }
    
}
```

commit, rollback 코드가 사라졌다. commit, rollback 코드는 transactionTemplate 에서 수행하고, 라이브러리 사용자(=개발자)가 수행할 비지니스로직은 Consumer 타입으로 받고있다.<br>

<br>

여기까지 해서 트랜잭션 템플릿까지 정리했다. TransactionTemplate을 이용하게 되면서 commit, rollback 로직을 여기 저기에서 사용하지 않고, 라이브러리 내부에서 비지니스로직과 함께 사용할 수 있었다. commit, rollback 메서드가 여기저기 퍼져있지 않게되었다.<br>

<br>

하지만, 아직 SQL 관련 Exception 을 처리하는 코드, 그리고 transactionTemplate 객체를 직접 주입받아서 처리하는 부분 등, DB 계층의 기술에 의존적인 코드가 남아있기는 하다. 이런 코드는 AOP 또는 `@Transactional` 인터페이스를 통해서 조금 더 발전시켜나갈 수 있다.<br>

<br>

<br>

<br>

<br>

아래에서부터는 이번주 금요일 부터 정리 예정... 이거 정리하다가 늙는것...같다... 당분간은 WebFlux 개념정리, 함수형 프로그래밍 관련해서 외국강의 들은 내용들 개념정리하는 데에 시간을 더 분배할 생각이기 때문이다...<br>

<br>

<br>

<br>

<br>

<br>

<br>

<br>

<br>

<br>

<br>

<br>

<br>

<br>

<br>

<br>

<br>

<br>

<br>

<br>

<br>

<br>

<br>

<br>

<br>

<br>

<br>

<br>

<br>

<br>

<br>

<br>

<br>

# AOP, @Transactional

정리가 덜됐다...

- 트랜잭션 리소스 초기화/회수 코드 분리
  - 선언적 방식
    - `@Transactional` 
  - AOP 를 사용한 로직 직접 구현
  - 프로그래밍 방식 
    - 테스트코드에서 트랜잭션을 검증할 때 사용
    - 자세한 내용은 스티브 프리드먼의 객체지향 설계와 실천 이라는 책에서도 언급되고 있다.

<br>



