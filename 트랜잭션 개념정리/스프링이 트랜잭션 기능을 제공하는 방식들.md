# 스프링이 트랜잭션 기능을 제공하는 방식들

> 처음 문서를 작성할 때는 나 조차도 어떻게 글을 써야 할지 막막해서 이것저것 다 쓰느라 글이 꽤 지저분했는데, 일주일 동안 다른 취준공부 등을 하느라 생각을 접어뒀었는데, 그 동안 뇌가 치유의 과정을 겪었나보다. <br>
>
> 오늘 트랜잭션 템플릿을 정리하면서, 어떻게 요약할지 조금 감이 잡히기 시작했다. 역시 초본은 깨끗하지 않다. 지속적으로 다듬어야 한다.<br>

<br>

스프링의 PlatformTransactionManager 를 구체화한 여러개의 클래스와, 이것들에 동기화 개념은 어떻게 적용되어있는지, 템플릿화는 어떻게 하고, 결국 `@Transactional` 이 스프링에서 사용되게 된 필요성은 무엇인지 정리한다. 김영한 님의 강의를 보고 공부를 했는데, 시간도 많이 들이셨을것 같고, 내부 소스도 모두 직접 파악하고, 예제를 직접 떠올려서 만드시는 것만 해도 시간을 많이 들이셨겠구나 하는 생각이 들었다.<br>

직접 공부를 하다보니,  예제를 직접 돌려봐야 트랜잭션 코드를 어떤 필요에 의해 추상화했고, 템플릿화를 왜 했는지, `@Transactional` 이 등장하게 된 계기는 뭔지 등에 대해 이해되는 것 같다. 아직은 프린트만 일단 보고 있다. 실제 강의는 하루 날 잡아서 완주해야겠다하고 생각중이다.<br>

실제 수업 프린트는 내가 적어놓은 설명에 비해 더 자세하고, 더 좋은 내용이 많다. 나는 그저 얕은 부분의 스토리만을 요약해두었을뿐.<br>

<br>

# 참고자료

- [스프링 DB 1편 - 데이터 접근 핵심 원리 대시보드 - 인프런 | 강의 (inflearn.com)](https://www.inflearn.com/course/스프링-db-1/dashboard)

혹시라도 내 깃헙을 보고 공부하는 사람들이 있을지는 모르겠지만, 혹시라도 있을 경우도 있기에, 자세한 내용은 강사님의 강의를 봐야만 이해가 가게끔 최대한 요약만 해둘 예정이다. 내 글은 그냥 요약정리 프린트처럼만 만들어놓을 예정<br>

그냥 노트에 필기해둔대로 두기에는, 백업이 너무 안되기에 결국 정리를 시작했다.<br>

이직을 하고 생활이 안정되면, 깃랩으로 모든 코드를 옮겨버리고 비공개로 전환하든가 해야할 것 같다.<br>

조금 불안하다 싶으면 바로 비공개로 전환할 예정.<br>

요즘 몰상식한 사람들이 너무 많아서... 내가 알아서 조심을 해야하는 것 같다.<br>

<br>

# 요약

요약해둘 내용은 아래와 같다.

- 트랜잭션 추상화
- 트랜잭션 동기화
- 트랜잭션 템플릿
  - jdbc commit/rollback
- 트랜잭션 리소스 초기화/회수 코드 분리
  - 선언적방식 : `@Transactional` 
  - AOP 를 사용한 로직 직접 구현
  - 프로그래밍 방식

<br>

# 트랜잭션 추상화

> Transaction 을 얻어오는 코드는 각 JDBC 추상화라이브러리마다 다르다. 스프링을 사용하면, `PlatformTrasactionManager` 을 통해서 어떤 JDBC 구체 라이브러리를 사용하든 `PlatformTranansactionManager` 타입에서 제공하는 메서드로 Transaction 객체를 얻어올 수 있다. <br>
>
> PlatformTransactionManager 는 아래의 메서드들을 제공한다.
>
> - getTransaction(TransactionDefinition) : TransactionStatus
> - commit(TransactionStatus) : void
> - rollback(TransactionStatus) : void
>
> Transaction 을 얻어오는 로직(=getTransaction(T))외에도 커밋(commit), 롤백(rollback) 역시도 `PlatformTransactionManager` 타입으로 어떤 JDBC 구체 라이브러리든 `commit(TransactionStatus) : void` , `rollback(TransactionStataus) : void` 를 통해 접근 가능하다.<br>
>
> 이렇게 다른 JDBC 구현 라이브러리를 사용하더라도 같은 타입인 `PlatformTrasactionManager`를 이용해 모두가 같은 메서드 들인 `getTranaction`, `commit`, `rollback` 을 사용하도록 공통화가 된다는 것은 장점이다. 이것에 대해서는 김영한님의 강의헤서는 **트랜잭션 추상화** 라는 개념으로 설명하고 있다.

<br>

JDBC 추상화 라이브러리(순수 JDBC 코드, JPA, Mybatis, QueryDSL, JOOQ 등등)마다 Transaction 획득, Transaction begin, end 처리, commit 처리를 하는 Java 코드는 다르다.<br>

만약 하나의 애플리케이션 내에서 여러 개의 라이브러리를 혼용해서 사용해야 하는 경우 Transaction 을 얻어올때 각 JDBC 추상화 라이브러리에 따라 다르게 구현된다.<br>

이렇게 JDBC 접근 코드가 데이터접근 코드마다 달라질 경우에 생각할 수 있는 가장 쉬운 방법은 `TxManager` 같은 클래스를 만들어서, 각 DB마다 다른 동작을 하도록 하는 클래스들을 만들어두는 것이다. 스프링은 이런 `TxManager` 클래스 같은 역할을 하는 `PlatformTransactionManager`라는 interface 를 제공하는데, `PlatformTransactionManager` 를 implments 한 클래스 들 중 원하는 클래스를 선택해서 인스턴스화 하는 Bean을 생성해서 등록해 사용할 수 있도록 해준다.<br>

PlatformTransactionManager는 아래와 같은 기능을 제공해주고 있다.

```java
public interface PlatformTransactionManager extends TransactionManager {
    TransactionStatus getTransaction(@Nullable TransactionDefinition definition)
			throws TransactionException;
    void commit(TransactionStatus status) throws TransactionException;
    void rollback(TransactionStatus status) throws TransactionException;
}
```

<br>

이런 `PlatformTrasactionManager` 라는 interface 를 `implements` 한 클래스로는 대표적으로 아래의 클래스들 이 있다.

- `DataSourceTransctionManager` 
- `JdbcTransactionManager`
- `JpaTransactionManager` 
- `EtcTrasactionManager`

<br>

스프링에서는 이렇게 `implements` 한 트랜잭션 매니저 클래스 들 중 하나를 선택해서 인스턴스화 하고 이것을 Bean 으로 등록해서 사용할수 있다.<br>

단순한 예제기반의 요약본은 추후 다른 문서에 정리 예정이다.<br>

<br>

# 트랜잭션 동기화

트랜잭션은 동기화가 필요하다. 스프링에서 제공하는 `PlatformTrasactionManager` 는 트랜잭션 동기화 매니저를 제공해주고 있다.

스프링에서 제공하는 각각의 `PlatformTransactionManager` 클래스를 implmenets 하는 각각의 구체 타입들은 내부적으로 트랜잭션 동기화 매니저클래스인 `TransactionSyncronizationManager` 를 이용해 트랜잭션을 얻는 과정을 동기화 한다.<br>

자세한 내용은 `TheadLocal` 을 통해 구현되어있다고 한다.<br>

즉, `DataSourceTransactionManager` , `JdbcTransactionManager`, `JpaTransactionManager`, `EtcTransactionManager` 등은 각각의  클래스 내부에서 `TransactionSyncronizationManager` 클래스를 사용한다.<br>

내부적으로 트랜잭션 동기화 매니저를 사용해 동기화를 수행하게끔 되어 있으므로, 사용자는 트랜잭션 동기화에 크게 신경쓰지 않아도 된다.<br>

**나머지 내용(UML)은 추후 정리 예정**<br>

`DataSourceTransactionManager` 클래스테서 동기화 매니저를 사용하는 부분을 살펴보자.

```java
public class DataSourceTransactionManager extends AbstractPlatformTransactionManager
		implements ResourceTransactionManager, InitializingBean {
    
    // ...

    @Override
	protected Object doGetTransaction() {
		DataSourceTransactionObject txObject = new DataSourceTransactionObject();
		txObject.setSavepointAllowed(isNestedTransactionAllowed());
		ConnectionHolder conHolder =
				(ConnectionHolder) TransactionSynchronizationManager.getResource(obtainDataSource());
		txObject.setConnectionHolder(conHolder, false);
		return txObject;
	}
    
    // ...
}
```

`TransactionSynconizationManager` 를 통해서 `ConnectionHolder` 를 얻고 있다.<br>

이번에는 `JpaTransactionManager` 클래스 내에서 동기화 매니저를 사용하는 부분을 살펴보자.<br>

```java
public class JpaTransactionManager extends AbstractPlatformTransactionManager
		implements ResourceTransactionManager, BeanFactoryAware, InitializingBean {
    
    // ...
    
    @Override
	protected Object doGetTransaction() {
		JpaTransactionObject txObject = new JpaTransactionObject();
		txObject.setSavepointAllowed(isNestedTransactionAllowed());

		EntityManagerHolder emHolder = (EntityManagerHolder)
				TransactionSynchronizationManager.getResource(obtainEntityManagerFactory());
		if (emHolder != null) {
			if (logger.isDebugEnabled()) {
				logger.debug("Found thread-bound EntityManager [" + emHolder.getEntityManager() +
						"] for JPA transaction");
			}
			txObject.setEntityManagerHolder(emHolder, false);
		}

		if (getDataSource() != null) {
			ConnectionHolder conHolder = (ConnectionHolder)
					TransactionSynchronizationManager.getResource(getDataSource());
			txObject.setConnectionHolder(conHolder);
		}

		return txObject;
	}
    
    // ...
    
}
```

<br>

# 트랜잭션 템플릿

**트랜잭션 추상화란? 요약**<br>

`Transaction` 객체를 얻어오는 로직, jdbc 및 JPA, Mybatis와 같은 데이터 접근 라이브러리마다 다르게 JAVA 코드로 작성되는 commit, rollback 로직들은 트랜잭션 추상화를 통해 해결됐다. 스프링에서는 `PlatformTransactionManager` 를  `implements` 하는 각각의 구체 타입인 아래와 같은 클래스들을 제공하고 있다.<br>

- `DataSourceTransctionManager` : JDBC
- `JdbcTransactionManager` : JDBC
- `JpaTransactionManager` : JPA
- `EtcTrasactionManager` : Mybatis, etc...

<br>

**트랜잭션 템플릿**<br>

데이터 라이브러리마다 다른 Transaction 을 얻어오는 로직은 `PlatformTransactionManager` 를 통해 해결했다. 그런데, 이제는 하나의 문제가 더 있다. 트랜잭션을 커밋하고, 예외가 발생했을 경우 롤백하는 로직은 아직 공통화하지 못했다.<br>

애플리케이션의 비즈니스 로직을 작성할 때마다 트랜잭션 커밋/롤백 로직은 개발자가 직접 작성해야 한다. 이 정도의 [Boilerplate code](https://en.wikipedia.org/wiki/Boilerplate_code) 는 사실 라이브러리 계층에서 공통화를 해주면 좋다. 스프링은 이런 기능을 공통화하는 기능을 제공하고 있다. 트랜잭션 템플릿을 통해서 해당 기능이 지원된다.<br>

<br>

스프링에는 [TransactionTemplate (Spring Framework 5.3.20 API)](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/support/TransactionTemplate.html) 클래스가 있다. 그리고 이 TransactionTemplate 클래스는 여러가지 interface들을 implments하고 있는데, 그 중 트랜잭션 템플릿 기능에 있어서 중요한 interface 와 상위클래스(부모클래스)는 아래와 같다.<br>

- [TransactionOperations](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/support/TransactionOperations.html) (interface)
- [DefaultTransactionDefinition](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/support/DefaultTransactionDefinition.html) (class)

<br>

이중에서 오늘 살펴볼 클래스(=사실은 interface)는 `TransactionOperations` 이다.<br>

TransactionOperations 인터페이스에서 제공하는 메서드는 아래와 같다.<br>

```java
public interface TransactionOperations {
	@Nullable
	<T> T execute(TransactionCallback<T> action) throws TransactionException;
    
	default void executeWithoutResult(Consumer<TransactionStatus> action) throws TransactionException {
		execute(status -> {
			action.accept(status);
			return null;
		});
	}
    
	static TransactionOperations withoutTransaction() {
		return WithoutTransactionOperations.INSTANCE;
	}
}

```

각 메서드를 간단하게 요약해서 정리해봤다.

**execute**<br>

- 참고 : [TransactionCallback (Spring Framework 5.3.20 API)](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/support/TransactionCallback.html) 
- 결과값을 리턴하는 transaction commit, rollback 구문을 작성할 때 사용한다.
- TransactionCallback 을 인자값으로 받는데, 어려워 보인다고 쫄지 말자. 한낱 함수형 인터페이스일 뿐이다. 그냥 [TransactionCallback](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/support/TransactionCallback.html) 내의 순수함수인`doInTransaction(TransactionStatus)` 메서드의 시그니처에 맞는 람다를 전달해주면 된다.(람다는 API 사용자인 프로그래머가 직접 입력해주면 된다.)
- 쉽게 이야기하면, TransactionCallback 메서드의 doInTransaction 메서드는 javascript에서 흔히 보이는 callback 함수처럼, callback 용도로 사용할 로직을 람다로 전달할 수 있다. 
- 그리고 이것은 Transaction 의 commit/rollback 전에 수행하는 것이다.

<br>

**executeWithoutResult**<br>

- 참고 : [TransactionOperations](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/support/TransactionOperations.html)
- 메서드 이름이 꽤 어려워 보이는데, 실상은 알고보면 어려운 함수가 아니다. 단순하게 execute 메서드를 감싸서, Result 를 리턴하지 않도록 해둔 메서드이다. 용도에 따라 유연하게 사용할 수 있도록 래핑해둔 메서드이다.
- 자세히 구현 내용을 보면 result 를 null 로 리턴하면서, 인자로 전달된 Comsumer 람다를 실행하게끔 되어 있다. 이렇게 전달된 Consumer 람다는 결국 TransactionCallback 람다로 실행하게 된다.

<br>

# 트랜잭션 리소스 초기화/회수 코드 분리

- 트랜잭션 리소스 초기화/회수 코드 분리
  - 선언적 방식
    - `@Transactional` 
  - AOP 를 사용한 로직 직접 구현
  - 프로그래밍 방식 
    - 테스트코드에서 트랜잭션을 검증할 때 사용
    - 자세한 내용은 스티브 프리드먼의 객체지향 설계와 실천 이라는 책에서도 언급되고 있다.

<br>



